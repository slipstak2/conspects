Оптимизация загрузки кэш-памяти команд: ассиметрия условий
   * Если условие в заголовке оператора ветвления часто оказывается ложным, выполнение кода становится линейным. Осуществляемая ЦП предвыборка инструкций ведет к тому, что неиспользуемый код загрязняет кэш-память команд L1i и вызывает проблемы с предсказанием переходов.
   * Ложные предсказания переходов делают условные выражение крайне неэффективными.
   * Асимметричные(статически смещенные в истинную или ложную сторону) условные выражения становятся причиной ложного предсказания переходов и "пузырей" (периодов ожидания ресурсов) в конвеере инструкций ЦП.
   * Реже исполняемый код должен быть вытестнен с основного вычислительного пути
   * Первый и наболее очевидный способ повышения эффективности загрузки кэш-памяти L1i - явная реорганизация блоков. Так, если условие P(x) чаще оказывается ложным, оператор вида:
      if (P(x)) statemantA; else statemantB;
   должен быть преобразован к виду:
      if (!P(x)) statementB; else statemantA;
   *  Второй способ решения той же проблемы основан на применении средств, предоставляемых GCC:
      * перекомпиляция с учетом результатов профилирования кода;
      * использование функций __builtin_expect
         - снабжает компилятор информацией, связанной с предсказанием переходов
         - сообщает компилятору, что наиболее вероятным значением выражения exp является c и возвращает exp
         
         long __builtin_expect(long exp, long c)
         
         #define unlikely(expr)     __builtin_expect(!!(expr), 0)
         #define likely(expr)       __builtin_expect(!!(expr), 1)
         
         int a;
         srand(time(NULL));
         
         a = rand() % 10;
         if (unlikely(a > 8)) { // условие ложно в 90% случаев
            foo();
         } else {
            bar();
         }
         
Оптимизация загрузки кэш-памяти команд:   встраивание функций
   * Эффективность встраивания функций объясняется способностью компилятора одновременно оптимизировать бОльшие кодовые фрагменты. Порождаемый же при этом машинный код способен лучше задействовать конвейерную архитектуру микропроцессора.
   * Обратной стороной встаивания является увеличиение объема кода и бОльшая нагрузка на кэш-память команд всех уровней(L1i, L2i,...), которая может привести к общему снижению производительности.
   * Функции, вызываемые однократно, подлежат обязательному встраиванию
   * Функции, многократно вызываемые из разных точек программы, не должны встаиваться независимо от размера
   
   // пример1: принудительное встанивание
   /* inline */ __attribute__((always_inline)) void foo() { ... }
   
   // пример2: принудительный запрет встраивания
   __attribute__((noinline)) void bar() { ... }
   
   
   
   Антишаблоны структурного программирования
   * "Загадночный" код (cryptic code) - выбор малоинформативных, часто однобуквенных идентификаторов
   * "Жесткий" код (hard code) - запись конфигурационных параметров как строковых, логических и числовых литералов, затрудняющих настройку и сопровождение системы.
   * Спагетти-код (spaghetti code) - несоблюдение правил выравнинваия, расстановки декоративных пробельных символов, а также превышение порога сложности одной процедуры(функции)
   * Магические числа(magic numbers) - неготовность определять как символические константы все числоые литералы за исключением, может быть 0, 1 и -1.
   * Применение функций как процедур (functions as procedures) - неготовность анализировать возвращаемый результат системных или пользовательских функций
   * "Божественные функции" (God functions) - функции, берущие на себя ввод данных, вычисления и вывод результатов или иные задачи, каждую из которых следует оформить самостоятельно.
   * Неиспользование переносимых типов - size_t, ptrdiff_t и др.
   * "Утечки" памяти (memory leaks) и внезапное завершение процесса вместо аварийного выхода из функции
   * Использование ветвлений с условиями, статически смещенными не к истинному, а к ложному результату
   * Недостижимый код (unreachable code)
   
   
   // не рекомендуется
   // см. SonarQube C Quality Profile [Sonar Way]
   // MINOR:: 'continue' should not be used
   int main(int argc, char *argv[]) {
      int i;
      for (i = 0; i < 10; i++) {
         if (i == 5) {
            continue;      /* Non-Compliant */
         }
         printf("i = %d\n", i);
      }
   }
   
         ....
         if (i != 5) {           /* Compliant */
            printf("i = %d\n", i);
         }
         

   4-частная структура памяти данных:
      - область данных, сегмент BSS и куча (входят в сегмент данных)
      - программный стек (не входит в сегмент данных)
      
   Область данных(data area) - используется для переменных со статической продолжительностью хранения, которые явно получили значение при инициализациии:
      * делится на область констант (read-only area) и область чтения-записи(read-write area)
      * инициализируются при загрузке программы, но до входа в функцию main на основании образа соответствующих переменных в объектом файле

   Сегмент BSS (BSS segment, .bss) - предназначен для статических переменных, не получивших значение при инициализации(инициализированы нулевыми битами):
      * располагается "выше" области данных(занимает более старшие адреса)
      * по требованию загрузчика ОС до входа в main() может эффективно заполить BSS нулями в блочном режиме(zero-full-on-demand)
      
   Куча(heap) - контролируется программистом посредством вызова, в том числе, функций malloc/free^
      * располагается "выше" сегмента BSS
      * является общей для все разделяемых библиотек и динамически загружаемых объектов(DLO, dynamically loaded objects) процесса

   Программный стек(stack) - содержит значения, передаваемые функции при ее вызове(stack frame), и автоматические переменные:
      * следует дисциплине LIFO;
      * растет "вниз" (противоположно куче);
      * обычно занимает самые верхние(максимальные) адреса виртуального адресного пространства
      

   malloc выделяет для нужд процесса непрерывный фрагмент оперативной памяти, складывающийся из блока запрошенного объема(адрес которого возвращается как  результат функции) и следующего перед ним блока служебной информации, имеющего длину в несколько байт:
      - размер выделенного блока
      - ссылку на следующий блок памяти в связанном списке блоков
      
      
   СТАНДАРТ POSIX
   
   POSIX(Portable Operating System Interface for UNIX) - набор стандартов, разработанные IEEE и Open Group для обеспечения совместимости ОС через унификацию их интерфейсов с прикладными программами(API), а также переносимость самих прикладных программ на уровне исходного кода на языке С.
   
   Потоки POSIX(POSIX threads, Pthreads) впервые введены стандратом POSIX 1003.1c-1995 и, с теоретической точки зрения, являются "легковесными" процессами ОС UNIX, которые в настоящее время поддерживаются во всех ОС семейства(Linux, AIX, HP-UX и пр.), а также в системах Microsoft Windows
      * Поток - единственная разновидность программного контекста, включающая в себя необходимые для исполнения кода аппаратные "переменные состояния": регистры, программный счетчик(PC), указатель на стек(SP) и т.д. Потоки компактнее, быстрее и более адаптивны, чем процесс UNIX, однако являются не единственным способом асинхронной организации вычислений.
   В модели с потоками процесс можно воспринимать как данные (адрессное пространство, дескрипторы файлов и т.п.) вкупе с одним или несколькими потоками, разделяющими его адресное пространство
   
   ЭЛЕМЕНТЫ МНОГОПОТОЧНОГО ПРОГРАММИРОВАНИЯ:
   * Поддержка многопоточного программирования со стороны ОС предполагает три важнейших асспекта: контекст исполнения, механизмы диспетчеризации(планирования исполнения и переключения контекстов) и синхронизации(координации совместного использования контекстами их общих ресурсов)
   * С архитектурных позицией, поддержка потоков POSIX состоит:
      * в предоставлении программисти ряда специфических "неясных" (opaque) переносимых типов: pthread_t, pthread_attr_t, pthread_mutex_t, pthread_cond_t и др.
      * в предоставлении набора функций создания, отсоединения, завершения потоков, блокировки мьютексов и т.д.
      * в механизме проверки наличия ошибок без использования errno.
   * Каждый поток POSIX имеет свою начальную функцию, аналогичную функции main процесса.
   
   
   #include <pthread.h>
   void *thread_routine(void *arg)
   {
      int errflag;
      // ...
      // отсоединить "себя" как поток POSIX до завершения
      errflag = pthread_detach(pthread_self());
      // проверить, удался ли вызов pthread_detach()
      if(errflag != 0)
         // ...
      // штатно завершить поток с возвратом значения void*
      return arg;    // вариант: return NULL и пр.
   }
   
   int main(int argc, char *argv[])
   {
      int errflag;
      pthread_t thread; // идентификатор потока
      
      // создать и запустить на исполнение поток POSIX
      errflag = pthread_create(
         &thread, NULL, thread_routine, NULL
      );
      if (errflag != 0)
         // ...
      // штатно завершить гл. поток и связанные с ним процесс
      return EXIT_SUCCESS;
   }
   
   ЗАПУСК ИСХОДНОГО И ДОПОЛНИТЕЛЬНЫХ ПОТОКОВ

   * Выполнение потока начинается с входа в его начальную функцию, вызываемую с единственным параметром типа void*.
      - Значение параметра начальной функции потока передается ей через pthread_create() и может быть равно NULL
   * Функция main() де-факто является начальной функцией исходного потока и в большинстве случаев вызывается средствами прилинкованного файла crt0.o, который инициализирует процесс и передает управление главной функции:
      - параметром main() является массив аргументов(argc, argv), а не значение типа void*; тип результата main() - int, а не void*;
      - возврат из main() в исходном потоке немедленно приводит к завершению процесса как такового;
      - для продолжения выполнения процесса после завершения main необходимо использовать pthread_exit(), а не return.
      
   ВЫПОЛНЕНИЕ И БЛОКИРОВКА ПОТОКА
   
   В общем случае выполнение потока может быть приостановлено:
      - если поток нуждается в недоступном ему ресурсе, то он блокируется
      - если потом снимается с исполнения(напр. по таймеру), то он вытесняется
   В связи с этим большая часть жизненного цилка потока связана с переходом между тремя состояниями:
      - готов - поток создан и не заблокирован, а потом пригоден для выполнения(ожидает выделения процессора)
      - выполняется - поток готов, и ему выделен процессор для выполнения;
      - заблокирован - поток ожидает условную переменную либо пытается захватить запертый мьютекс или выполнить операцию ввода-вывода, которую нельзя немедленно завершить, и т.д.
      

   ЗАВЕРШЕНИЕ ПОТОКА
   
   Стандартными способами завершения потоков являются:
      - штатный возврат из начальной функции (return);
      - штатный вызов pthread_exit завершающимся потоком;
      - вызов pthread_cancel другим потоком(PTHREAD_CANCELLED)
   Если завершающийся поток был "отсоединен" (detached), он сразу уничтожается. Иначе поток остается в состоянии "завершен" и доступен для объединения с другими потоками. В ряде источников такой поток носит назнвание "зобми".
      - Завершенный процесс сохраняет в памяти свой идентификатор и значение результата, переданное return или pthread_exit.
      - Поток-"зомби" способен удержать(почти) все ресурсы, которые он использовал при своем выполнении.
   Во избежании возникновения потоков-"зомби" потоки, не предполагающие объединения, должные всегда отсоединяться
   
   
   УНИЧТОЖЕНИЕ ПОТОКА
   
   Поток уничтожается по окончании выполнения:
      - если он был отсоединен сами собой или другим потоком во время своего выполнения
      - если он был создан отсоединенным(PTHREAD_CREATE_DETACHED)
   Поток уничтожается после пребывания в состоянии "завершен":
      - после отсоединения(pthread_detach)
      - после объединения (pthread_join)
   Уничтожение потока высвобождает ресурсы системы или процесса, которые не были освобождены при переходе потока в состояние "завершен", в том числе:
      - место хранения результата
      - стек, память с содержимым регистров ЦП и др.
   
   
   КРИТИЧЕСКИЕ СЕКЦИИ И ИНВАРИАНТЫ
   
   * Инвариант - постулированное в коде предположение, в большинстве случаев - о связи между данными(наборами переменных) или их состоянии. Формулировка инварианта как логического выражения позволяет смотреть на него как на предикат
      - Инварианты могут нарушаться при исполнении изолированных частей кода, по окончании которых должны быть восстановлены со 100% гарантией
   
   * Критическая секция - участок кода, который производит логически связанные манипуляции с разделяемыми данными и влияет на общее состояние системы
      - Если два потока обращаются к разным разделяемым данным, оснований для возникновения ошибок нет. Поэтому, как правило, говорят о критических секция "по переменной x" или "по файлу f"
      
   ВЗАИМНЫЕ ИСКЛЮЧЕНИЯ И СИТУАЦИЯ ГОНОК
   * Организация работы потоков, при которой два(и более) из них не могут одновременно пребывать в критических секциях по одним данным, носит название взаимного исключения.
   * При одновременном доступе нескольких процессов к разделяемым данным могут возникать проблемы, связанные с очередностью действий
   * Ситуация, в которой результат зависит от последовательности событий в независимых потоках(или процессах), называется гонками(состязанием).
      - Нежелательные эффекты в случае гонок возможны, в том числе, только при чтении данных.
   * В ОС UNIX обеспечение взаимных исключений строится на кратковременном запрете прерываний и возлагается на ядро ОС. Блокировать процесс(поток) может только ОС.

   МЬЮТЕКСЫ
   
   * В общем случае под мьютексом(mutex) понимается объект с двумя состояниями(открыт/заперт) и двумя атомарными операциями:
      - операция "открыть" всегда происходит успешно и незамедлительно возвращает управление, переводят мьютекс в состояние "открыт".
      - операция "закрыть" (условный, или неблокирующий вариант) может быть реализована как булева функция, незамедлительно возвращающая "истину" для открытого мьютекса(который при этом ей закрывается) или "ложь" для закрытого мьютекса(EBUSY)
      - операция "закрыть"(блокирующий вариант) может быть реализована как процедура, которая закрывает открытый мьютекс (и незамедлительно возвращает управление) или блокирует поток до момента отпирания закрытого мьютекса, после чего закрывает его и возвращает управление.
   * В стандарте Pthreads мьютексы, задача которых - сохранить целостность асинхронной системы, реализованы как переменные в пользовательском потоке, ядро ОС поддерживает лишь операции над ними
   * Мьютексы могут создаваться как статически, так и динамически. После инициализации мьютекс всегда открыт:
      pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
   * Потоки POSIX поддерживают как блокирующий так и неблокирующий вариант закрытия мьютексов.
   * Неиспользуемый мьютекс может быть уничтожен. На момент уничтожения мьютекс должен быть открыт
   * Обобщением мьютекса является семафор Дейкстры, реализованный в Pthreads как объект типа sem_t
   
   
   ИСПОЛЬЗОВАНИЕ МЬЮТЕКСА:
   
   #include<pthread.h>
   
   typdef struct {
      pthread_mutex_t mutex;  // мьютекс для защиты значения
      int             value;  // защищаемое значение
   } data_t;
   
   // разделяемый объект; мьютекс инициализируется статически
   data_t      data = {PTHREAD_MUTEX_INITIALIZER, 1};
   
   void *thread_routine(void *arg)
   {
      pthread_mutx_t * mutex = &data.mutex;
      int errflag;
      // закрыть (блокировать) мьютекс до изменения данных
      errflag = pthread_mutex_lock(mutex);
      // проверить удался ли вызов pthread_mutex_lock()
      if (errflag != 0) // ...
      
      data.value *= 2;  // изменение данных
      
      // открыть(отпереть) мьютекс после изменения данных
      errflag = pthread_mutex_unlock(mutex);
      // проверить удался ли вызов pthread_mutex_unlock()
      if (errflag != ) // ...
      return arg; // вариант: return NULL и пр.
   }
   
   ИСПОЛЬЗОВАНИЕ НЕСКОЛЬКИХ МЬЮТЕКСОВ: СТРАТЕГИИ БЛОКИРОВОК
   * По архитектурным сооображениями одного мьютекса может быть недостаточно(напр., мьютекс A может защищать "голову" списка, а мьютекс B - текущий обрабатываемый элемент), при этом существует риск возникновения взаимных блокировок и прочих проблем синхронизации потоков.
   * Защита двумя и более мьютексами взаимно независимых данных является тривиальной, необходимость же одновременого закрытия двух и более мьютексов по взаимнозависимым (связанным) данных в разных потоках может повлечь проблемы
   * Успешными статегиями блокировок по двум и более мьютексам являются:
      - фиксированная иерархия блокировок - установление единого порядка закрытия и открытия мьютексов в каждом потоке
      - "попытаться и откатить" - блокирующее закрытие первого мьютекса из набора с последующим неблокирующим(например pthread_mutex_trylock()) вызовом закрытия для оставшихся и "аварийным" открытием всех мьютексов в случае неудачи
      
   Критерий                            Фиксированная иерархия              "Попытаться и откатить"
   Эффективность                          Выше                                   Ниже
   Гибкость                               Ниже                                   Выше
   Строгость протокола закрытия           Выше                                   Ниже
   
   
   УСЛОВНЫЕ ПЕРЕМЕННЫЕ
   
   * Механизм условных переменных (condition variable) позволяет организовать практически любые протоколы взаимодействия потоков POSIX, блокируя их выполнение до наступления заданного события(выполнения предиката) или момента времени.
   * Использование условных переменных предполагает:
      - статическую инициализацию или динамическое создание и уничтожение условных переменных
      - ожидание выполнения условия (с возможностью указать абсолютное астрономическое время снятия блокировки - блокировка с тайм-аутом)
      - широковещательное оповещение и (или) передачу сигналов(не смешивать с сигналами UNIX!)
   * Переносимым типом условной переменной в Pthrea ds является pthread_cond_t
   
   #include <pthread.h>
   typdef struct {
      pthread_mutex_t mutex;  // мьютекс для защиты значения
      pthread_cond_t  cond;   // усл. перем. для коммуник.
      int             value;  // защищаемое значение
   } data_t;
   
   // разделяемый объект; мьютекс и условная переменная
   // инициализируются статически
   data_t         data = {PTHREAD_MUTEX_INITIALIZER, PTHREAD_COND_INITIALIZER, 0};
   
   void *thread_routine(void *arg)
   {
      int errflag;
      errflag = pthread_mutex_lock(&data.mutex);
      if (errflag != 0) // ...
      
      data.value = 1;      // изменить данные
      // послать сигнал об изменении разделяемых данных
      errflag = pthread_cond_signal(&data.cond);
      if (errflag != 0) // ...
      errflag = pthread_mutex_unlock(&data.mutex);
      if (errflag != 0) //...
      return arg;    // вариант 
   }
   
   
   int main(int argc, char *argv[])
   {
      int errflag;
      struct timespec   timeout;
      
      // ...
      timeout.tv_sec = time(NULL) + 1;
      timeout.tv_nsec = 0;
      
      // БЛОКИРОВКА ПОТОКА НА УСЛОВНОЙ ПЕРЕМЕННОЙ
      // ТРЕБУЕТ ПРЕДВАРИТЕЛЬНОГО ЗАКРЫТИЯ МЬЮТЕКСА
      errflag = pthread_mutex_lock(&data.mutex);
      if (errflag != 0) // ...
      
      while (data.value == 0) {     // 1-ая проверка предиката
         errflag = pthread_cond_timedwait(&data.cond, &data.mutex, &timeout);
         if (errflag = ETIMEDOUT) {
            break;      // завершение блокировки по тайм-ауту
         } else {
            // ошибка при вызове pthread_cond_timedwait()
         }
      }
      if (data.value != 0) ...   // 2-я проверка предиката
      
      errflag = pthread_mutex_unlock(&data.mutex);
      if (errflag != 0) // ...
      return EXIT_SUCCESS;
   }
   
   Подробнее в Butenhof, D. Programming with POSIX Threads (Addison-Wesley, 1997).
   Примеры: https://github.com/snikulov/prog_posix_threads
   
   
   ЗАКОН ДЖ. АМДАЛА
   
   * Фундаментальное ограничение на рост производительности системы с увеличением количества вычислительных узлов сформулировано Дж. Амдалом(Gene Amdahl), установившим, что ускорение выполнения кода за счет распаралеливания ограчено временем, затрачиваемое на последовательные действия.
   
   Если задача разделяется на несколько частей, суммарное время ее выполнения на параллельной системе не может быть меньше времени выполнения самого длинного фрагмента. Формально:
                     1
            Sp = ----------------------
                            1 - alpha
                 alpha +   ------------
                                p
   где alpha - доля вычислений, которая может быть получена только последовальными расчетами;
   p - количество параллельных узлов (потоков), или разрешенных к использованию процессоров;
   Sp - ускорение система в сравнении с 1-процессорной
   
   
   ПРЕИМУЩЕСТВА МНОГОПОТОЧНОГО ПРОГРАММИРОВАНИЯ
   
   * Наряду с выгодой от эффективного использования аппаратного ("истинного") параллелизма, многопоточное программирование:
      - стимулирует к поддержанию оптимальной модульной структуры исходного кода
      - способствует ясному отражению зависимостей между частями программы на уровне исходного кода, а не комментариев в нем
      - содействует "здоровой" изоляции независимых или слабо связанных между собой вычислительных путей (потоков), явным образом(через мьютексы, семафоры, условные переменные, очереди соообщений и соответствующие программные вызовы и конструкции языка) синхронизиумых только по мере реальной необходимости
      - повышает удобство сопровождения и развития кодовой базы
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   