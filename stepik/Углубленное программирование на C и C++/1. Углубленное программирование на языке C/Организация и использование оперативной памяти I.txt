Модели управления памятью и области видимоссти объектов данных
* Предлагаемые языком С модели управления объектами данных(переменными) закреплены в понятии класса памяти, которое охватывает:
   * время жизни - продолжительность хранения объекта в памяти
   * область видимости - части исходног окода программы, из которых можно получить доступ к объекту по идентификатору
   * связывание - части исходного кода, способные обращаться к объекту по его имени
* Для языка С характерны три области видимости:
   * блок - фрагмент кода, ограниченный фигурными скобками(напр. составной оператор), либо заголовок функции, либо заголовок оператора for, while, do while и if/
   * прототип функции
   * файл
   
   
   Одномерные массивы:
   
   // с освобождением квадратных скобок
   int a[] = {1, 2, 3};
   // эквивалентно int a[3] = {1, 2, 3}
   
   // c частичной неявной инициализацией
   int b[5] = {1, 2, 3};
   // эквивалентно:
   // int b[5] = {1, 2, 3, 0, 0}
   
   // c выделеннымм иницилизаторами
   int c[7] = {1, [5] = 10, 20, [1] = 2};
   // эквивалентно:
   // int c[7] = {1, 2, 0, 0, 0, 10, 20};
   
   
   
   int scanf(const char *restrict format, ...)     - Возвращает количество успешно считанных элементов ввода
   Причины ошибок: 
      Некорректная входная последовательность(EILSEQ)
      Недостаточно аргументов (EINVAL)

   int printf(const char *restrict format, ... )   - Возвращает количество переданных в поток байт
   Причины ошибок:
      EILSEQ, EINVAL
      
   void *malloc(size_t size)  - выделяет неиспользуемый участок памяти объекту данных размера size байт, не меняя содержимое указанного участка
   
   void *calloc(size_t nelem, size_t elsize) - выделяет участок памяти массиву из nelem элементов размера elsize байт каждый и выполняет его поразрядное обнуление
   
   Причины ошибок: Недостаточно памяти ENOMEM
   
   void *realloc(void *ptr, size_t size)  - изменяет размер объекта данных на который указывает ptr до size. Если указатель ptr пуст, вызов эквивалентен malloс. Если size = 0, память под объектом освобождается
   
   void free(void *ptr) - вызывает освобождение памяти, на которую указывает ptr, делая ее доступной до нового выделения. Дальнейшее использование ptr влечет неопределенное поведение.
   
   free НИКОГДА НЕ ВЫЗЫВАЕТ ОШИБОК
   
   
   Одним из способов повышения производительности программы является такое размещение данных в ОЗУ, при котором они эффективно загружаются в кэш-память ЦП. Для этого данные должны быть, как минимум выравнены на границу линии кэш-памяти данных 1-ого уровня(L1d). Выравнивание объекта в ОЗУ обычно определяется характеристиками выравнивания, которые имеет соответсвующий тип данных. При этом:
   
   * выравнивание скалярного объекта определяется собственной характеристикой выравнивания приписанного ему базового типа;
   * выравнивание массива, - если размер каждого элемента не кратен величине выравнивания, - распространяет свое действие только на элемент с индексом 0;
   * выравнивание объектов в программе на языке С может регулироваться на уровне отдельных переменных и типов данных, для чего в компиляторе GCC служит атрибут aligned
   * вравнивание статически рамещаемых переменных имеет силу как для глобальных, так и для автоматических переменных. При этом характеристика выравнивания, присущая типу объекта, полностью игнорируется.
   * при выравнивании массивов гарантированно выравнивается только начальный, нулевой элемент массива
   
   // выравнивание, регулируемое на уровне объекта
   // переменная gwd выравнивается на границу 64 байт
   uint64_t gwd __attribue((aligned(64)));
   
   typedef int __attribute((aligned(128))) al128int_t;
   al128int_t aln;
   
   Выравнивание объектов, размещаемых динамически. Функция posix_memalign