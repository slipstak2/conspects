ОБЪЕКТНО-ОРИЕНТИРОВАННОЕ ПРОЕКТИРОВАНИЕ: ОБЩИЕ СВЕДЕНИЯ
Цель объектно-ориентированного проектирования - разработка архитектуры(дизайна) сложных программных систем в соответствии с заданными или общепринятыми критериями качества и с учетом реализуемости архитектуры на выбранном языке объектно-ориентированного программирования.
Критерии качества архитектуры, как правило, обеспечивают:
   * возможность повторного использования;
   * гибкость настройки;
   * расширяемость и переносимость;
   * структурированность и модульность;
   * компактность и разумные уровень детализации;
   * понятность и простоту(в том числе взаимодействия компонентов)
   
ПРОЕКТИРОВАНИЕ КАК ИСКУССТВО КОМПРОМИССА. ПРОБЛЕМЫЕ ПРОЕКТИРОВАНИЯ
Решение задач объектно-ориентированного проектироваия в большинстве случаев предполагает достижения множества компромиссов, например:
   * соответствие дизайна задача <- -> общность дизайна
   * доступность элементов системы <- -> безопасность;
   * удобство вызова <- -> возможность тонкой настройки
При этом основные проблемы объектно-ориентированного проектирования сводятся, главным образом, к следующим:
   * Проблема №1. Идентификация объектов
   * Проблема №2. Определение степени детализации
   * Проблема №3. Определение интерфейса объекта.
   * Проблема №4. Определение реализации объекта.
   
ПРОБЛЕМА №1-2. ОПРЕДЕЛЕНИЕ СОСТАВА И СТЕПЕНИ ДЕТАЛИЗАЦИИ ОБЪЕКТОВ
ПРОБЛЕМЫ №3-4. ОПРЕДЕЛЕНИЕ ИНТЕРФЕЙСА И РЕАЛИЗАЦИИ ОБЪЕКТОВ

ПРИЧИНЫ ПЕРЕПРОЕКТИРОВАНИЯ

Явное задание классов при создании объектов:
   * привязка к реализации(классу), а не к интерфейсу(типу).
Явное задание способа выполнения операций:
   * сужение множества вариантов обслуживания запроса до единственного возможного
Зависимость от программной и(или) аппаратной платформы
Зависимость клиента от представления или реализации объекта:
   * потенциальная необходимость модификации клиента при изменении способа представления, хранения или реализации объекта.
Зависимость от алгоритмов.
Сильная связанность классов:
   * формирование монолитных систем без слоевой структуры структуры.
Чрезмерное использование наследования

МАКСИМЫ ПРОЕКТИРОВАНИЯ
Не решать каждую задачу "с нуля". Инкапсулировать допускающие изменения элементы дизайна и поведения(напр., алгоритмы, состояния, процессы создания объектов)
Программировать в соответствии с интерфейсом, а не с реализацией(Programmin to interfaces):
   * клиент не должен обладать информацией о типах используемых объектов, если они имеют ожидаемый интерфейс
   * клиент не должен знать о классах, посредством которых используемые объекты реализованы.
Проектировать системы с учетом будущих изменений
Предпочитать композицию объектов, а не наследование классов.
Использовать возможности языка программирования.

ШАБЛОНЫ (ПАТТЕРНЫ) ПРОЕКТИРОВАНИЯ
Обобщенные типовые архитектурные решения задач объектно-оринтированного проектирования известны как шаблоны(паттерны) проектирования.
Примечание: использованый ранее термин "шаблон класса (функции)" известен в английском языке как class(function) template. Для обозначения архитектурных шаблонов применяется англоязычное design pattern.
Один из первых авторитетных каталогов шаблонов проектирования составлен Э.Гаммой(Erich Gamma), Р.Хелмом(Richard Helm), Р. Джонсоном(Ralph Johnson) и Дж.Влиссидесом(John Vlissides), известными как "банда четырех"(GoF - Gang of Four) и опубликовавшими книгу Design Patterns: Elements of Reusable Object-Oriented Software.

ШАБЛОНЫ: ОПРЕДЕЛЕНИЕ И ПРЕИМУЩЕСТВА. ТИПОЛОГИЯ ШАБЛОНОВ
По определению членов GoF, шаблон - это описание взаимодействия объектов и классов, адаптированных для решения общей задачи проектирования в конкретном контексте
Активное использование шаблонов проектирования позволяет:
   - повысить качество кода
   - улучшить техническую документацию
   - обеспечить качество сопровождение ПО
В зависимости от цели использования шаблоны делятся на три категории:
   - порождающие - описывают процессы создания объектов
   - структурные - описывают способы композиции классов(объектов)
   - поведенические - описывают взаимодействие классов(объектов) между собой
   
ПРОСТРАНСТВО ШАБЛОНОВ GoF

Уровень применения  |   Порождающие шаблоны(5)            | Структурные шаблоны(8)  |  Поведенические шаблоны(11)  |
==========================================================|=========================|==============================|
Класс               |   Фабричный метод                   | Адаптер класса          |  Интерпретатор               |
                    |                                     |                         |  Шаблонный метод             |
--------------------|-------------------------------------|-------------------------|------------------------------|
Объект              |   Абстрактная фабрика               | Адаптер объекта         |  Итератор                    |
                    |   Класс с единственным экземпляром  | Декоратор               |  Команда                     |
                    |   Прототип                          | Заместитель             |  Наблюдатель                 |
                    |   Строитель                         | Компоновщик             |  Посетитель                  |
                    |                                     | Мост                    |  Посредник                   |
                    |                                     | Приспособленец          |  Состояние                   |
                    |                                     | Фасад                   |  Стратегия                   |
                    |                                     |                         |  Хранитель                   |
                    |                                     |                         |  Цепочка ответственности     |
====================================================================================================================

БАЗОВЫЕ ШАБЛОНЫ: НАСЛЕДОВАНИЕ И КОМПОЗИЦИЯ
Наследование классов(inheritance) и композция объектов(composition) является распространненными приемами повтороного использования функцониальных возможностей объектно-ориентированных систем, а потому могут рассматриваться как базовые шаблоны.

                  Наследование                     Композиция
=======================================================================================
Что?              Определяет реализацию            Определяет реализацию одного 
                  класса в терминах другого        объекта в терминах другого объекта
                  (white-box reuse)                (black-box reuse)

Как?              Определение подкласса            Определение атрибута
                                                   (объединение объектов)
Когда?            При компиляции(статически)       При компиляции(статически) или 
                                                   при выполнении(динамически)

НАСЛЕДОВАНИЕ И КОМПОЗИЦИЯ: "ЗА" и "ПРОТИВ"

Критерий качества                    Наследование      Композиция
====================================================================
Реализация и модификация             Простая           Сложная
Зависимость от реализации            Высокая           Низкая
Соблюдение инкапсуляции              Нет               Есть
Замена реализации при выполнении     Невозможна        Возможна
Необходимость тщательного
проектирования интерфейса            Нет               Есть
Гибкость и возможность
повторного применения                Низкая            Высокая
Размер класса                        Большой           Небольшой
Количество используемых объектов     Мало              Много
====================================================================

ТРИ СПОСОБА КОМПОЗИЦИИ
====================================================================================
Характеристика участника        Инкапсуляция      Инкапсуляция      Инкапсуляция
Implementer                      экземпляра        ссылки            указателя
====================================================================================
Обязательность                   Обязателен        Обязателен        Необязателен
Количество(кратность)            1 .. *            1 .. *            0 .. *
Зависимость времени жизни        Зависит           Не зависит        Не зависит
(ВЖ) от ВЖ агрегата              (совпадает)      (совпадает или
                                                   превышает)
Возможность совместного         Нет                Есть              Есть
использования
Определение атрибута           Implementer impl;  Implementer &impl; Implementer *impl;


АГРЕГИРОВАНИЕ ИЛИ ОСВЕДОМЛЕННОСТЬ?
Агрегирование(aggregation) и осведомленность(acquaintace) - две стороны композиции. Различия между ними весьма существенны, хотя и определяются предполагаемым использование объектов, а не механизмами языка.

Характеристика                      Агрегирование              Осведомленность
================================================================================
Семантика                           "Содержит", "владеет",     "Знает", "использует",
                                    "несет ответственность"    "ассоциирован c ..."
Сила                                Сильное                    Слабое
Постоянство                         Высокое                    Низкое
Частота применения                  Низкая                     Высокая
Время жизни                         Одинаково для агрегата     Любое
                                    и составляющих
Инкапсулируемый элемент             Экземпляр, ссылка          Ссылка, указатель
                                    указатель
                                    
БАЗОВЫЕ ШАБЛОНЫ: ДЕЛЕГИРОВАНИЕ
Делегирование(delegation) - передача ответственности за выполнение запроса клиента от непосредственного получателя(делегирующей стороны, delegator) уполномоченному (делегату, delegate). Различают делегирование при наследовании классов и при композиции объектов.
Назначение делегирования - абстрагирование(при композиции - также инкапсуляция) поведения(реакции на клиентский запрос). Шаблон делегирования используется в целом ряде шаблонов GoF("посетилель", "стратегия" и др.)
Ключевое достоинство делегирования - упрощение композиции поведений на стадии выполнения. Ключевой недостаток делегирования - трудность статического анализа и понимания сильно параметризованного исходного кода.

ДЕЛЕГИРОВАНИЕ: РЕАЛИЗАЦИЯ
                                       Наследование                  Композиция
Получатель                             Производный класс             Объект на стороне "целое"
Уполномоченный                         Базовый класс                 Объект на стороне "часть"
Доступ к получателю                    Указатель this                Указатель на получателя
                                                                     (должен быть передан)
Абстрактная семантика                  "Является"                    "Содержит"

БАЗОВЫЕ ШАБЛОНЫ: НЕИЗМЕНЯЕМЫЕ ОБЪЕКТЫ
Неизменяемый объект(immutable object) - шаблон, позволяющий создать программный объект, структурно не допускающий модификации после(окончательного) создания.
Основное предназначение шаблона - устранение дорогостоящих операций копирования и сравнения объектов путем использования семантики ссылок.
В дизайне систем различают неизменность объекта:
   * с точки зрения самой системы и е пользователей
   * на битовом(внутримашинном) и абстрактном(логическом) уровне.
Достоинства неизменяемого объекта:
   * константность, гарантируемая компилятором
   * потоковая безопасность, структурная надежность
   * простота анализа и понимания кода
   
НЕИЗМЕНЯЕМЫЕ ОБЪЕКТЫ: РЕАЛИЗАЦИЯ
Реализация неизменяемого объекта на языке С++ предполагает:
   * полное построение объекта конструктором класса(кроме отложенной инициализации подмножества атрибутов)
   * полное отсутствие неконстантных открытых статических и нестатических атрибутов(без спецификатора const или со спецификатором mutable)
   * отсутствие мутаторов, изменяющих состояние всего объекта(для побитовой неизменяемости) или части, видимой извне пользователю(для логическиой неимзенности)

БАЗОВЫЕ ШАБЛОНЫ: ИНТЕРФЕЙС
Интерфейсный класс, или интерфейс(interface) - шаблон структурирующих способы доступа к одному или нескольким (другим) классам.
Классическое назначение интерфейса - определение нового абстактного типа данных(ADT) в целях его дальнейшего повторного использования. Такой абстактный тип обычно не содержит никаких данных, но демонстрирует необходимое поведение.
Достоинство интерфейса состоит в обеспечении возможности статической или динамической замены конкретных классов, реализующих указанный интерфейс.

ПОРОЖДАЮЩИЕ ШАБЛОНЫ: ОБЩИЕ СВЕДЕНИЯ
Порождающие шаблоны:
   * абстрагируют процессы создания объектов и инкапсулируют сведения об инстанцируемых классах.
   * обеспечивает независимость системы от способа создания, композиции и представления объектов.
   * наиболее важны для систем, основанных на композиции больше, чем на наследовании

Порождающие шаблоны GoF: 
   * Абстрактная фабрика               (Abstract Factory)
   * Строитель                         (Builder)
   * Фабричный метод                   (Factory Method)
   * Прототип                          (Prototype)
   * Класс с единственным экземпляром  (Singleton)

ПОРОЖДАЮЩИЕ ШАБЛОНЫ: АБСТРАКТНАЯ ФАБРИКА
Абстрактная фабрика(инструментарий, kit) - шаблон уровня объекта, представляющий интерфейс для создания семейств взаимосвязанных(взаимозависимых) объектов
Используется, когда:
   * система не должна зависеть от способов создания, компоновки и представления объектов
   * объекты разных семейств гарантированно не должны использоваться совместно
   * используемое семейство объектов должно являться параметром конфигурации системы.
Участники: абстрактная фабрика, конкретная фабрика, абстрактный продукт, конкретный продукт, клиент.

ПОРОЖДАЮЩИЕ ШАБЛОНЫ: СТРОИТЕЛЬ
Строитель - шаблон уровня объекта, отделяющий конструирование сложного объекта от его представления.
Используется, когда:
   * алгоритм создания сложного объекта не должен зависеть от состава объекта и способов компоновки его частей
   * процесс конструирования объекта должен обеспечивать его различные представления
Участники: абстрактый строитель, конкретный строитель, распорядитель, продукт, клиент


ПОРОЖДАЮЩИЕ ШАБЛОНЫ: ФАБРИЧНЫЙ МЕТОД
Фабричный метод(виртуальный конструктор, virtual constructor) - шаблон уровня класса, определяющий абстрактный интерфейс создания объектов и делегирующий выбор типов инстанцируемых объектов конкретным подклассам.
Используется, когда:
   * заранее неизвестен типа инстанцируемых объектов
   * дизайн класса с фабричным методов предполагает, что создаваемые объекты специфицируются подклассами
   * класс делегирует свои обязанности по инстанцированию объектов одному из своих подклассов.
Участники: абстрактный создатель, конкретный создатель, абстрактный продукт, конкретный продукт.

ПОРОЖДАЮЩИЕ ШАБЛОНЫ: ПРОТОТИП
Прототип - шаблон уровня объекта, определяющий вид создаваемого объекта при помощи экземпляра-прототипа, который явно копируется при создании объекта
Используется, когда:
   * инстанцируемые классы определяются динамически
   * необходимо избежать возникновения иерархии классов или фабрик, параллельных иерархиям классов продуктов
   * количество прототипов невелико
Участники: абстрактный прототип, конкретный прототип, клиент.

ПОРОЖДАЮЩИЕ ШАБЛОНЫ: КЛАСС С ЕДИНСТВЕННЫМ ЭКЗЕМПЛЯРОМ
Класс с единственным экземпляром(одиночка, синглтон, singleton) - шаблон уровня объекта, гарантирующий, что класс располагает единственным экземпляром, и предоставляющий к нему глобальную точку доступа
Используется, когда:
   * экземпляр класса должен быть один и только один
   * экземпляр класса должен быть доступен из любого клиента
   * класс должен допускать порождение подклассов с возможностью работать с ними без модификации клиентской части системы.
Участник: одиночка

КЛАСС С ЕДИНСТВЕННЫМ ЭКЗЕМПЛЯРОМ: МИНИМАЛЬНАЯ РЕАЛИЗАЦИЯ
class Singleton {
   public:     static Singleton* Instance();
   protected:  Singleton();
   private:    static Singleton* _instance;
}

Singleton* Singleton::_instance = NULL;

Singleton* Singleton::Instance() {
   if (_instance == NULL) {
      _instance = new Singleton;
   }
   return _instance;
}

СТРУКТУРНЫЕ ШАБЛОНЫ: ОБЩИЕ СВЕДЕНИЯ
Структурные шаблоны:
   * определяет порядок композиции(взаимосвязи) объектов, интерфейсов и реализаций.
   * абстрагируют процессы построения программных структур, более крупных, чем отдельные классы и экземпляры

Структурные шаблоны GoF:
   * Адаптер                  (Adapter)
   * Декоратор                (Decorator)
   * Мост                     (Bridge)
   * Компоновщик              (Composite)
   * Фасад                    (Facade)
   * Приспособленец           (Flyweight)
   * Заместитель              (Proxy)

СТРУКТУРНЫЕ ШАБЛОНЫ: АДАПТЕР
Адаптер(обертка, wrapper) - шаблон уровня класса или объекта преобразующий интерфейс одного класса в интерфейс другого и обеспечивающий интерфейс одного класса в интерфейс другого и обеспечивающий совместную работу классов с несовместимыми интерфейсами.
Используется, когда:
   * необходимо использовать класс, интерфейс которого не отвечает предъявляемых требованиям
   * повторно используемый класс должен взаимодействовать с заранее известными или на связанными с ним классами с несовместимыми интерфейсами
   * необходимо использовать подклассы, (а) от которых для адаптации нежелательно порождать новый подклассы, но (б) их общий предок может быть адаптирован.
Участники: адаптер, целевой и адаптируемый классы, клиент.


СТРУКТУРНЫЕ ШАБЛОНЫ: МОСТ
Мост(описатель/тело, handle/body) - шаблон уровня объекта, отделяющий абстракцию от ее реализации с тем, чтобы каждая из них могла независимо изменяться, расширяться и использоваться повторно.
Используется когда:
   * необходимость избежать неразрывной связи абстракции с реализацией
   * абстракция и реализация должны расширяться путем наследования
   * изменения в реализации не должны сказываться на клиентах абстракции
   * необходимо скрыть реализацию абстракции от клиентов
   * реализация требует обобществления между несколькими объектами, и этот факт должен быть скрыт
Участники: абстракция, уточненная абстракция, реализация, конкретная реализация.

СТРУКТУРНЫЕ ШАБЛОНЫ: КОМПОНОВЩИК
Компоновщик - шблон уровня объектов, объединяющий их в древовидные структуры вида "часть-целое" и предоставляющий пользователям иерархий унифицированный интерфейс для работы с примитивными и составными объектами.
Использовается, когда:
   * необходимо сформировать иерархию объектов вида "часть-целое"
   * необходимо обеспечиваться одинаковую трактовку примитивных и составных объектов
Участники: компонент, составной объект, лист, клиент

СТРУКТУРНЫЕ ШАБЛОНЫ: ДЕКОРАТОР
Декоратор(обертка, wrapper) - шаблон уровня объекта, динамически назнающий объекту новый фунционал.
Используется, когда:
   * дополнительный фунционал должен динамически и прозначным для клиента образом назначаться и сниматься с объекта.
   * невозможно или неудобно расширять функциональные возможности объекта путем порождения подклассов - например, по причине комбинаторного роста количества независимых расширений.
Участники: абстрактный и конкретный компонент, абстрактный и конкретный декоратор.

СТРУКТУРНЫЕ ШАБЛОНЫ: ФАСАД
Фасад - шаблон уровня объекта, предоставляющий единый, упрощенный, высокоуровневый интерфейс к подсистеме и действующий наряду с интерфейсами отдельных ее объектов.
Используется когда:
   * требуется простой интерфейс к совокупности сложных, взаимодействующих и взаимозависимых объектов(подсистеме)
   * стоит задача изолировать подсистему от клиента и других подсистем, повысить степень переносимости, независимости, избавиться от лишних связей между объектами
   * необходимо декомпозировать систему(подсистему) на слои(уровни)
Участники: фасад, классы подсистемы

СТРУКТУРНЫЕ ШАБЛОНЫ: ЗАМЕСТИТЕЛЬ
Заместитель(суррогат, surrogate) - шаблон уровня объекта, реализующий суррогатный объект и контролирующий доступ к предоставляемому объекту.
Частные случае:
   * удаленный заместитель - локально представляет объект из другого адресного пространства
   * виртуальный заместитель - создает "тяжеловесные" объекты по требованию
   * защищающий заместитель - контролирует доступ к представляемому объекту
   * "умная" ссылка("умный" указатель) - дополняет традиционную семантику ссылок(указателей) техниками отложенной инициализации, подсчета ссылок, управлениям блокировками и др.

Используется когда:
   * необходимо ссылкаться на объект более тонко, чем при помощи "обычного" указателя
Участники: заместитель, абстрактный и реальный субъект

ПОВЕДЕНЧЕСКИЕ ШАБЛОНЫ: ОБЩИЕ СВЕДЕНИЯ
Поведенические шаблоны:
   * систематизируют распределение обязанностей между объектами
   * характеризуют поток управления программы
   * реализуют типичные способы взаимодействия объектов
Поведенческие шаблоны GoF:
   * Интерпретатор            (Interpreter)
   * Команда                  (Command)
   * Цепочка ответственности  (Chain of Responsibility)
   * Итератор                 (Iterator)
   * Хранитель                (Memento)
   * Состояние                (State)
   * Наблюдатель              (Observer)
   * Стратегия                (Strategy)
   * Посредник                (Mediator)
   * Посетитель               (Visitor)
   * Шаблонный метод          (Template Method)
   
ПОВЕДЕНЧЕСКИЕ ШАБЛОНЫ: КОМАНДА
Команда(действие, action; транзакция, transaction) - шаблон уровня объекта, инкапсулирующие запрос как объект.
Используется, когда:
   * необходимо делать запросы параметрами объектов - аналогично функциям обратного вызова
   * необходимо отправлять запросы неизвестным объектам-получателям
   * необходимо ставить запросы в очередь, хранить и протоколировать их
   * необходимо отменять результаты запросов и повторно их исполнять
Участники: абстрактная и конкретная команда, инициатор, получатель, клиент.

КОМАНДА "БЕЗ ПАМЯТИ" ШАБЛОН КЛАССА
template <class Receiver>
class SimpleCommand : public Command {
   public:
      typedef  void(Receiver::* Action) ();
      SimpleCommand(Receiver r, Action a) : _receiver(r),
                                            _action(a) {}
      virtual void Execute();
   private:
      Action      _action;
      Receiver*   _receiver;
}

КОМАНДА "БЕЗ ПАМЯТИ" РЕАЛИЗАЦИЯ И ИСПОЛЬЗОВАНИЕ
template <class Receiver>
void SimpleCommand<Receiver>::Execute() {
   (_receiver->*action)();
}

// в точке использования
SomeClass* receiver = new SomeClass();

// ...
Command* command = new SimpleCommand<SomeClass>(receiver, &SomeClass::Action);

//..
command->Execute();

ПОВЕДЕНЧЕСКИЕ ШАБЛОНЫ: ИТЕРАТОР
ИТЕРАТОР(курсор, cursor) - шаблон уровня объекта, предоставляющий механизм последовательного доступа к элементам составного объекта без нарушения инкапсуляции его программного представления.
Используется когда:
   * необходимо обеспечение доступа к содержимому агрегата без раскрытия его представления
   * требуется поддержать несколько активных точек и (или) способов обхода одного агрегата.
   * должен существовать (быть создан) унифицированный интерфейс обхода различный агрегирующих структур - полиформфная итерация
Участники: абстрактный и конкретный агрегат, абстрактный и конкретный итератор

ИТЕРАТОР: ЧАСТНЫЕ СЛУЧАЕ
Частные случаи:
   * внешний итератор - обходом агрегата управляет "активный" клиент
   * внутренний итератор - обход агрегата осуществляется итератором(при "пассивном" клиенте)
   * курсор - использует алгоритм обхода, определяемый агрегатом, и лишь указывает на текущую позицию в нем
   * устойчивый итератор - гарантирует, что операции вставки и удаления не препятствуют обходу по агрегату без копирования последнего.
   * итератор с расширенным интерфейсом - реализует операции, дополнительные к first(), next(), isDone() и currentItem()
   * полифорфный итератор - как правило, создается фабричным методом и удаляется клиентом
   * пустой итератор - обслуживает обработку граничных условий, является вырожденным(isDone() возвращает true)

Итератор:
   По стороне управления обходом:
      внешний(активный)
      внутренний (пассивный)
   По месту определения алгоритма:
      курсор
   По устойчивости к операциям над агрегатом
      устойчивый
   По совместимости с агрегатом
      полифорфный
   По мощности интерфейса
      с минимальным интерфейсом
      с расширенным интерфейсом
Пустой итератор

ВНЕШНИЙ ИЛИ ВНУТРЕННИЙ ИТЕРАТОР?
                              Внешний итератор                 Внутренний итератор
Сторона управления            Клиент                           Итератор
Место определение алгоритма   Клиент                           Итератор
                                                               Агрегат(для курсоров)
Роль клиента                  Активный                         Пассивный
Функции клиента               Запрашивает следующий            Передает операцию для применения
                              элемент                          к каждому посещенному элементу
Гибкость подхода              Высокая                          Низкая
Простота обхода               Средняя                          Высокая
Обход рукурсивных агрегатов   Затруднен                        Не вызывает проблем
                                                               (используется стек вызовов)
                                                               
ПОВЕДЕНЧЕСКИЕ ШАБЛОНЫ: ПОСРЕДНИК
Посредник - шаблон уровня объекта, абстрагирующий способ кооперирования большого числа объектов
Используется когда:
   * необходимо обеспечить слабую связанность системы
   * избавить от явных множественных перекрестных ссылок друг на друга объекты со сложныыми, неструктурированными и трудными для понимания связями
   * затруднено повторное использование объекта, активно участвующего в информационном обмене с другими его участниками
   * поведение, распределенное между классами, должно настраиваться без создания большого числа подклассов
Участники: абстрактный и конкретный посредник, объект-коллега

ПОВЕДЕНЧЕСКИЕ ШАБЛОНЫ: НАБЛЮДАТЕЛЬ
Наблюдатель(подчиненные, dependents; издатель/подписчик, publish/subscribe) - шаблон уровня объекта, определяющий связть "один ко многим" для обновления всех объектов, зависимых от изменившегося объекта
Используется, когда:
   * существуют(выявлены) для аспекта абстракции, один из которых является зависимым от другого - например, "данные - представление"
   * предполагается, что изменение состояния одного объекта повлечет за собой изменение других объектов, которые заранее неизвестны.
   * необходимо обеспечить возможность извещения одним объектом других, предположения о которых отсутствуют у инициатора извещений
Участники: абстрактный и конкретный субъект, абстрактный и конкретный наблюдатель

ВЫТЯГИВАНИЕ ИЛИ ПРОТАЛКИВАНИЕ?
                           Модель проталкивания       Модель вытягивания
                              (push)                     (pull)
Активная сторона              Субъект                  Наблюдатель
Содержимое поссылки        Детальная информация       Минимальное уведомление
                           об изменениях
Информированность          Высокая                    Низкая(нулевая)
субъекта о наблюдателях
Степерь повторного         Низкая                     Высокая
использования субъектов
Общая эффективность        Выше                       Ниже
модели

ПОВЕДЕНЧЕСКИЕ ШАБЛОНЫ: СОСТОЯНИЕ
Состояние - шаблон уровня объекта, предоставляющий таковому возможность измения свое поведение с учетом своего текущего состояния.
Используется, когда:
   * поведение объекта зависит от его состояния и должно динамически изменяться
   * в системе присутствуют многочисленные, структурно идентичные условные операторы, в которых выбор ветви зависит от состояния объекта
Участники: контекст, абстрактное и конкретное состояние

ПОВЕДЕНЧЕСКИЕ ШАБЛОНЫ: СТРАТЕГИЯ
Стратегия(политика, policy) - шаблон уровня объекта, определяющий семейство алгоритмов, инкапсулирующий каждый из них и делающий их взаимозаменяемыми
Используется когда:
   * множество родственных классов отличается исключительно поведением
   * необходимо наличие нескольких вариантов одного алгоритма - например, оптимизированного по использованию ресурсов памяти(один) и процессора(другой)
   * нежелательно раскрывать клиенту сложные, специфичные для алгоритма структуры данных
   * класс содержит множество вариантов поведения, представленных разветвленными условными операторами
Участники: абстрактная и конкретная стратегия, конктекст

ПАРАМЕТРИЗАЦИЯ СТРАТЕГИЙ ШАБЛОНА КЛАССА-КОНТЕКСТА
template <class Strategy> class Context {
   public: // ...
      void operation() { _strategy.doAlgorithm(); }
   private:
      Strategy _strategy;
};

class SomeStrategy {
   public:
      void doAlgorithm();
};

// в точке использования
Context<SomeStrategy> context;

ПОВЕДЕНЧЕСКИЕ ШАБЛОНЫ: ШАБЛОННЫЕ МЕТОД
Шаблонный метод - шаблон уровня класса, один из фундаментальных приемов повторного использования кода. Определяет логическую структуру аллгоритма и позволяет подклассам определить(переопределить) его некоторые шаги.
Используется когда:
   * имеется возможность однократно определить инвариантные части алгоритма и делегировать реализацию изменяющегося поведения производным классам.
   * необходимо локализировать в одном классе(метода) поведение, общее для подклассов, - пример техники "вынесения за скобки для обобщения"
   * актуален вопрос управляемости расширений в подклассах - в точках вызова операций-зацепок(hook operation)

Участники: абстрактный и конкретный класс.

"ЗАЦЕПКИ" или примитивные операции?

                                     Операция зацепка             Примитивная операция
Роль в шаблонном методе          Метод с реализацией по           Абстрактный метод(чисто
                                 умолчанию (часто пустой)         виртуальная функция)
Подлежит перекрытию              Если необходимо                  Да

"РОДИТЕЛЬСКИЙ КОНТРОЛЬ"
// без шаблонного метода
void DerivedClass::operation() {
   ParentClass::operation();
   // ...
}

// c шаблонным методом
void ParentClass::operation() {
   // ...
   hookOperation();
}

void ParentClass::hookOperation() {}
void DerivedClass::hookOperation() { /* */}

ПОВЕДЕНЧЕСКИЕ ШАБЛОНЫ: ПОСЕТИТЕЛЬ
Посетитель - шаблон уровня объекта, средство описания операции, выполняемой с каждым объектом из некоторой структуры
Используется когда:
   * необходимо определить новую операцию над объектами класса, не модифицируя класс
   * в структуре присутствуют объекты различных классов(и типов!), над которыми требуется выполнять операции, зависящие от класса
   * над объектами в составе структуры необходимо выполнять разнообразные операции, которые нецелесообразно выключать в состав классов
   * номенклатура классов структуры стабильна, но часто пополняется новыми операциями
Участники: абстрактный и конкретный посетитель, абстрактный и конкретный элемент, структура объектов

ДВОЙНАЯ ДИСПЕТЧЕРИЗАЦИЯ
Двойная диспетчеризация - известная в языках программирования техника выбора вызываемой операции в зависимости от двух типов:
Примечание: В контексте шаблона "посетитель" операция выбирается в зависимости от типа конкретного посетителя и конкретного элемента.
Двойная диспетчеризация является частным случаем множественной диспетчеризации и не поддерживается в С++ напрямую.
Примечание: Поддерживаемая С++ одинарная диспетчеризация предполагает, что операция выбирается исходя из имени запроса (идентификатора операции) и класса объекта-получателя. Поддержка двойной диспетчеризации в С++ свела бы ценность данного шаблона к нулю

СТРУКТУРА АБСТРАКТНОГО ПОСЕТИТЕЛЯ
class Visitor {
   public:
      virtual void visitElementA(ElementA*);
      virtual void visitElementB(ElementB);
      // ...
   protected:
      Visitor();
};

СТРУКТУРА АБСТРАКТНОГО И КОНКРЕТНОГО ЭЛЕМЕНТОВ
class Element {
   public:
      virtual ~Element();
      virtual void Accept(Visitor &) = 0;
   protected:
      Element();
};
class ElementA: public Element {
   public:
      ElementA():
      virtual void Accept(Visitor &visitor) {
         visitor.visitElementA(this)
      }
}

НЕУСТРАНИМЫЕ КОНФЛИКТЫ В АРХИТЕКТУРЕ
Достижение эксптреаальных достижений одних показателей качества системы нередко приводят к недопустимому "провалу" по другим показателям. Подобные ситуации составляют суть конфликтов в архитектуре, многие из которых неустранимы. Например:
   * скорость работы - объем требуемой памяти
   * гибкость - простота
   * САР-теорема(Э.Брюер, 2000). В любой реализации распределенных вычислений возможно обеспечить не более 2 из 3 следующих свойств:
      (1) согласованность данных - во всех вычислительных узлах в один момент времени данные не противоречат друг другу
      (2) доступность - любой запрос к распределенной системе завершается корректным откликом
      (3) устойчивость к разделению - расщепление распределенной системы на несколько изолированных секций не приводит к некорректности отклика от каждой из секций.
      
CAP-теорема
The CAP Theorem. You can have at most two of these properties for any shared-data system: Consistency, Availability, Tolerance to network Partitions.
   * CA - системы с поддержкой ACID-транзакций(напр. LDAP):
      * ACID - атомарность, согласованность, изолированность, надежность
   * AP - "слабо целостные" системы с приемлемым уровнем практической значимости хранения даных(напр. DNS)
   * CP - распределенные системы, способные функционировать при распаде, но допускающие отсутствие отклика
Согласованность(С)
Доступность    (A)
Устойчивость   (P)

Закон Деметра
Закон Деметра[для функций и методов](Law of Demeter for Functions/Methods, LoD-F) - правило, относящееся к дизайну и стилю оформления объектно-ориентированного кода в соответствии с принципом "наименьшего знания" об экземплярах классов внутри(и более широко - оранизации) вызываемхы методов. Формально,  LoD-F гласит:
   Метод M объекта O вправе вызывать только методы:
      * самого себя
      * своих параметров
      * любых объектов, экземпляры которых он создает
      * своих прямых подобъектов
Соблюдение LoD-F позволяет достичь наименьше возможности связанности объектов и стабильности кода при изменении глубинных структур объектов.

ШАБЛОНЫ GRASP
Альтернативным каталогом шаблонов ОО-проектирования, имеющим несомненный авторитет, является каталог К.Лармана(Craig Larman) GRASP(General Responsibility Assignment Software Patterns)
Девятку шаблонов GRASP образуют:
   * Информационный эксперт   (Information Expert)
   * Создатель                (Creator)
   * Контроллер               (Controller)
   * Сильная связность        (High Cohesion)
   * Слабое зацепление        (Low Coupling)
   * Полиморфизм              (Polymorphism)
   * Чистая выдумка           (Pure Fabrication)
   * Посредник                (Indirection)
   * Сокрытие реализации      (Protected Variation)









