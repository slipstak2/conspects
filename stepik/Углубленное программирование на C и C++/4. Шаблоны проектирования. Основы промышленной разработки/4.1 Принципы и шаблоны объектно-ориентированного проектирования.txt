ОБЪЕКТНО-ОРИЕНТИРОВАННОЕ ПРОЕКТИРОВАНИЕ: ОБЩИЕ СВЕДЕНИЯ
Цель объектно-ориентированного проектирования - разработка архитектуры(дизайна) сложных программных систем в соответствии с заданными или общепринятыми критериями качества и с учетом реализуемости архитектуры на выбранном языке объектно-ориентированного программирования.
Критерии качества архитектуры, как правило, обеспечивают:
   * возможность повторного использования;
   * гибкость настройки;
   * расширяемость и переносимость;
   * структурированность и модульность;
   * компактность и разумные уровень детализации;
   * понятность и простоту(в том числе взаимодействия компонентов)
   
ПРОЕКТИРОВАНИЕ КАК ИСКУССТВО КОМПРОМИССА. ПРОБЛЕМЫЕ ПРОЕКТИРОВАНИЯ
Решение задач объектно-ориентированного проектироваия в большинстве случаев предполагает достижения множества компромиссов, например:
   * соответствие дизайна задача <- -> общность дизайна
   * доступность элементов системы <- -> безопасность;
   * удобство вызова <- -> возможность тонкой настройки
При этом основные проблемы объектно-ориентированного проектирования сводятся, главным образом, к следующим:
   * Проблема №1. Идентификация объектов
   * Проблема №2. Определение степени детализации
   * Проблема №3. Определение интерфейса объекта.
   * Проблема №4. Определение реализации объекта.
   
ПРОБЛЕМА №1-2. ОПРЕДЕЛЕНИЕ СОСТАВА И СТЕПЕНИ ДЕТАЛИЗАЦИИ ОБЪЕКТОВ
ПРОБЛЕМЫ №3-4. ОПРЕДЕЛЕНИЕ ИНТЕРФЕЙСА И РЕАЛИЗАЦИИ ОБЪЕКТОВ

ПРИЧИНЫ ПЕРЕПРОЕКТИРОВАНИЯ

Явное задание классов при создании объектов:
   * привязка к реализации(классу), а не к интерфейсу(типу).
Явное задание способа выполнения операций:
   * сужение множества вариантов обслуживания запроса до единственного возможного
Зависимость от программной и(или) аппаратной платформы
Зависимость клиента от представления или реализации объекта:
   * потенциальная необходимость модификации клиента при изменении способа представления, хранения или реализации объекта.
Зависимость от алгоритмов.
Сильная связанность классов:
   * формирование монолитных систем без слоевой структуры структуры.
Чрезмерное использование наследования

МАКСИМЫ ПРОЕКТИРОВАНИЯ
Не решать каждую задачу "с нуля". Инкапсулировать допускающие изменения элементы дизайна и поведения(напр., алгоритмы, состояния, процессы создания объектов)
Программировать в соответствии с интерфейсом, а не с реализацией(Programmin to interfaces):
   * клиент не должен обладать информацией о типах используемых объектов, если они имеют ожидаемый интерфейс
   * клиент не должен знать о классах, посредством которых используемые объекты реализованы.
Проектировать системы с учетом будущих изменений
Предпочитать композицию объектов, а не наследование классов.
Использовать возможности языка программирования.

ШАБЛОНЫ (ПАТТЕРНЫ) ПРОЕКТИРОВАНИЯ
Обобщенные типовые архитектурные решения задач объектно-оринтированного проектирования известны как шаблоны(паттерны) проектирования.
Примечание: использованый ранее термин "шаблон класса (функции)" известен в английском языке как class(function) template. Для обозначения архитектурных шаблонов применяется англоязычное design pattern.
Один из первых авторитетных каталогов шаблонов проектирования составлен Э.Гаммой(Erich Gamma), Р.Хелмом(Richard Helm), Р. Джонсоном(Ralph Johnson) и Дж.Влиссидесом(John Vlissides), известными как "банда четырех"(GoF - Gang of Four) и опубликовавшими книгу Design Patterns: Elements of Reusable Object-Oriented Software.

ШАБЛОНЫ: ОПРЕДЕЛЕНИЕ И ПРЕИМУЩЕСТВА. ТИПОЛОГИЯ ШАБЛОНОВ
По определению членов GoF, шаблон - это описание взаимодействия объектов и классов, адаптированных для решения общей задачи проектирования в конкретном контексте
Активное использование шаблонов проектирования позволяет:
   - повысить качество кода
   - улучшить техническую документацию
   - обеспечить качество сопровождение ПО
В зависимости от цели использования шаблоны делятся на три категории:
   - порождающие - описывают процессы создания объектов
   - структурные - описывают способы композиции классов(объектов)
   - поведенические - описывают взаимодействие классов(объектов) между собой
   
ПРОСТРАНСТВО ШАБЛОНОВ GoF

Уровень применения  |   Порождающие шаблоны(5)            | Структурные шаблоны(8)  |  Поведенические шаблоны(11)  |
==========================================================|=========================|==============================|
Класс               |   Фабричный метод                   | Адаптер класса          |  Интерпретатор               |
                    |                                     |                         |  Шаблонный метод             |
--------------------|-------------------------------------|-------------------------|------------------------------|
Объект              |   Абстрактная фабрика               | Адаптер объекта         |  Итератор                    |
                    |   Класс с единственным экземпляром  | Декоратор               |  Команда                     |
                    |   Прототип                          | Заместитель             |  Наблюдатель                 |
                    |   Строитель                         | Компоновщик             |  Посетитель                  |
                    |                                     | Мост                    |  Посредник                   |
                    |                                     | Приспособленец          |  Состояние                   |
                    |                                     | Фасад                   |  Стратегия                   |
                    |                                     |                         |  Хранитель                   |
                    |                                     |                         |  Цепочка ответственности     |
====================================================================================================================

БАЗОВЫЕ ШАБЛОНЫ: НАСЛЕДОВАНИЕ И КОМПОЗИЦИЯ
Наследование классов(inheritance) и композция объектов(composition) является распространненными приемами повтороного использования функцониальных возможностей объектно-ориентированных систем, а потому могут рассматриваться как базовые шаблоны.

                  Наследование                     Композиция
=======================================================================================
Что?              Определяет реализацию            Определяет реализацию одного 
                  класса в терминах другого        объекта в терминах другого объекта
                  (white-box reuse)                (black-box reuse)

Как?              Определение подкласса            Определение атрибута
                                                   (объединение объектов)
Когда?            При компиляции(статически)       При компиляции(статически) или 
                                                   при выполнении(динамически)

НАСЛЕДОВАНИЕ И КОМПОЗИЦИЯ: "ЗА" и "ПРОТИВ"

Критерий качества                    Наследование      Композиция
====================================================================
Реализация и модификация             Простая           Сложная
Зависимость от реализации            Высокая           Низкая
Соблюдение инкапсуляции              Нет               Есть
Замена реализации при выполнении     Невозможна        Возможна
Необходимость тщательного
проектирования интерфейса            Нет               Есть
Гибкость и возможность
повторного применения                Низкая            Высокая
Размер класса                        Большой           Небольшой
Количество используемых объектов     Мало              Много
====================================================================

ТРИ СПОСОБА КОМПОЗИЦИИ
====================================================================================
Характеристика участника        Инкапсуляция      Инкапсуляция      Инкапсуляция
Implementer                      экземпляра        ссылки            указателя
====================================================================================
Обязательность                   Обязателен        Обязателен        Необязателен
Количество(кратность)            1 .. *            1 .. *            0 .. *
Зависимость времени жизни        Зависит           Не зависит        Не зависит
(ВЖ) от ВЖ агрегата              (совпадает)      (совпадает или
                                                   превышает)
Возможность совместного         Нет                Есть              Есть
использования
Определение атрибута           Implementer impl;  Implementer &impl; Implementer *impl;


АГРЕГИРОВАНИЕ ИЛИ ОСВЕДОМЛЕННОСТЬ?
Агрегирование(aggregation) и осведомленность(acquaintace) - две стороны композиции. Различия между ними весьма существенны, хотя и определяются предполагаемым использование объектов, а не механизмами языка.

Характеристика                      Агрегирование              Осведомленность
================================================================================
Семантика                           "Содержит", "владеет",     "Знает", "использует",
                                    "несет ответственность"    "ассоциирован c ..."
Сила                                Сильное                    Слабое
Постоянство                         Высокое                    Низкое
Частота применения                  Низкая                     Высокая
Время жизни                         Одинаково для агрегата     Любое
                                    и составляющих
Инкапсулируемый элемент             Экземпляр, ссылка          Ссылка, указатель
                                    указатель
                                    
БАЗОВЫЕ ШАБЛОНЫ: ДЕЛЕГИРОВАНИЕ
Делегирование(delegation) - передача ответственности за выполнение запроса клиента от непосредственного получателя(делегирующей стороны, delegator) уполномоченному (делегату, delegate). Различают делегирование при наследовании классов и при композиции объектов.
Назначение делегирования - абстрагирование(при композиции - также инкапсуляция) поведения(реакции на клиентский запрос). Шаблон делегирования используется в целом ряде шаблонов GoF("посетилель", "стратегия" и др.)
Ключевое достоинство делегирования - упрощение композиции поведений на стадии выполнения. Ключевой недостаток делегирования - трудность статического анализа и понимания сильно параметризованного исходного кода.

ДЕЛЕГИРОВАНИЕ: РЕАЛИЗАЦИЯ
                                       Наследование                  Композиция
Получатель                             Производный класс             Объект на стороне "целое"
Уполномоченный                         Базовый класс                 Объект на стороне "часть"
Доступ к получателю                    Указатель this                Указатель на получателя
                                                                     (должен быть передан)
Абстрактная семантика                  "Является"                    "Содержит"

БАЗОВЫЕ ШАБЛОНЫ: НЕИЗМЕНЯЕМЫЕ ОБЪЕКТЫ
Неизменяемый объект(immutable object) - шаблон, позволяющий создать программный объект, структурно не допускающий модификации после(окончательного) создания.
Основное предназначение шаблона - устранение дорогостоящих операций копирования и сравнения объектов путем использования семантики ссылок.
В дизайне систем различают неизменность объекта:
   * с точки зрения самой системы и е пользователей
   * на битовом(внутримашинном) и абстрактном(логическом) уровне.
Достоинства неизменяемого объекта:
   * константность, гарантируемая компилятором
   * потоковая безопасность, структурная надежность
   * простота анализа и понимания кода
   
НЕИЗМЕНЯЕМЫЕ ОБЪЕКТЫ: РЕАЛИЗАЦИЯ
Реализация неизменяемого объекта на языке С++ предполагает:
   * полное построение объекта конструктором класса(кроме отложенной инициализации подмножества атрибутов)
   * полное отсутствие неконстантных открытых статических и нестатических атрибутов(без спецификатора const или со спецификатором mutable)
   * отсутствие мутаторов, изменяющих состояние всего объекта(для побитовой неизменяемости) или части, видимой извне пользователю(для логическиой неимзенности)

БАЗОВЫЕ ШАБЛОНЫ: ИНТЕРФЕЙС
Интерфейсный класс, или интерфейс(interface) - шаблон структурирующих способы доступа к одному или нескольким (другим) классам.
Классическое назначение интерфейса - определение нового абстактного типа данных(ADT) в целях его дальнейшего повторного использования. Такой абстактный тип обычно не содержит никаких данных, но демонстрирует необходимое поведение.
Достоинство интерфейса состоит в обеспечении возможности статической или динамической замены конкретных классов, реализующих указанный интерфейс.










































