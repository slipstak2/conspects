ИДИОМЫ ЯЗЫКА ПРОГРАММИРОВАНИЯ?...
Идиома - пригодная для многократного применения характерная конструкция языка высокого уровня, средство выражения семантики и самостоятельный инструмент программирования, обеспечивающий простую и удобную запись кода, требуемуемю структуру, гибкость реализации архитектуры системы и т.д.
В отличие от универсальных шаблонов, идиомы языков программирования отражают особенность их грамматики и семантики, а значит, позволяют добиться большего при выражении архитектурных идей, решении сложных задач, оптимизации и тонкой настройке кода. Знание идиом - признак свободного владения языком программирования.

Пространство идиом С++. Идиомы процедурного программирования
Идиомы С++ покрывают не вытекающие из его синтаксиса аспекты, придающие языку эффективность, совместимость с языком С и удобство использования, и допускают классификацию по таким признакам, как:
   * уровень сложности
   * степень переносимости в другие языки(из других языков)
   * отношение к парадигме программирования и т.д.
Из языка С в С++ вошли идиомы процедурного программирования:
   for(;;);          // пустой бесконечный цикл
   while(1) foo();   // цикл с тождественным истинным условием

   // постфиксный декремент, адресная арифметика и др.
   while (*cp++ = *cp2++)
   
Пространство идимо С++. Объектно-ориентированные идиомы: обзор
Объектно-ориентированные идиомы С++ охватывают все аспекты языковой поддержки парадигмы объектно-ориентированного программирования включая:
   * систему статического контроля типов времени компиляции
   * систему динамической идентификации типов времени выполнения(RTTI)
   * абстрактые и конкретные типы данных(структуры и классы)
   * управление доступом
   * инициализацию и уничтожение объектов
   * инкапсуляцию, наследование, полифорфизма подклассов
   * перегрузку операций-функций(operator =, operator <<, operator >>)
   
КЛАССЫ ИЛИ СТРУКТУРЫ?

                          Структура                  Класс
Базовая семантика         Простой агрегат(данные,    Пользовательский тип
                          вложенные типы)            (без ограничений)
Наличие конструкторов     Редко                      В большинстве случаев
и деструкторов            
Уровень доступа к         Открытые(public)           Закрытые(private)
членам по умолчанию       
Использование в           Да                         Да
шаблонах                  
Использование в           Да                         Да
иерархиях наследования    
Примеры                   std::pair<T1, T2>          std::vector<T>
                          boost::is_void<T>

ОБЪЕКТНО-ОРИЕНТИРОВАННЫЕ ИДИОМЫ С++: ПРИМЕРЫ
Тривиальные конструктор:
   * формируется автоматически
   * не инициализирует значение POD-типов
   * рекурсивно вызывается для объектов базовых классов
Конструктор(операция-функция) почленного копирования(присваивания) по умолчанию:
   * формируются автоматически
   * выполняют поверхностную инициализацию(присваивание)
Отсутствие наследование конструкторов:
   class A;
   A a;        // вызов A::A(), если есть
   A b(a)      // вызов A::A(A&), если есть
   
Инициализация и уничтожение объектов автоматической и динамической памяти
Связывание инициализации объекта с его созданием
Неявный параметр нестатических методов классов - псевдопеременная this
class A;
A *pa = new A(42);            // вызов A::A(int)
A *pa2 = new A[n];            // вызов A::A(), N раз

// освобожение памяти с вызовом A::~A()
delete [] pa2;
// освобождение памяти без вызова A::~A()
// delete pa2;

ИДИОМЫ ПОВЫШЕННОГО УРОВНЯ СЛОЖНОСТИ
Перегруженные операции, в том числе:
   * операция индексирования агрегатов: operator [] - допускает контекстно-зависимую перегрузку в зависимости от использования в лево- и праводопустимых выражениях
   * операция выделения памяти: operator new
   * операция освобождения памяти: operator delete
   * операция доступа у указателю: operator ->
   * операция приведения к POD-типам: operator double, operator char, др.
Функциональные объекты(функторы)
Подсчет ссылок и указателей - квазиавтоматическая сборка мусора из динамической памяти
Объекты переменного размера и др.

ИДИОМА №1. Контекстно-зависимая перегрузка индексирования
class ARef {      // фиктивный класс
   public:
      ARef(A &a, int i): _a(a), ix(i) {}
      // запись t в _a
      ARef& operator = (T t)     { return *this; }
      // чтение из _a в _t
      operator T()               { return _t}
private:
   A&    _a;   //ссылка на агрегат
   int  _ix;   // индекс в агрегате
   T     _t;   // T - гл. обр. базовый тип
}


class A {                  // агрегат
  friend class ARef;       // для повышения производительности
  public:
      A() { /* */ }
      ARef operator [] (int ix) { return ARef(*this, ix); }
};

// в точке использования
A a;     int i,j;       T t;
a[i] = t;      // (a.operator[](i)).operator = (t);
t = a[j];      // t = (a.operator[](j)).operator T();













