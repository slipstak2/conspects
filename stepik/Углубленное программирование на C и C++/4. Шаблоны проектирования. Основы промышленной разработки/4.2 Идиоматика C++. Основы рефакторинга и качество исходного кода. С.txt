ИДИОМЫ ЯЗЫКА ПРОГРАММИРОВАНИЯ?...
Идиома - пригодная для многократного применения характерная конструкция языка высокого уровня, средство выражения семантики и самостоятельный инструмент программирования, обеспечивающий простую и удобную запись кода, требуемуемю структуру, гибкость реализации архитектуры системы и т.д.
В отличие от универсальных шаблонов, идиомы языков программирования отражают особенность их грамматики и семантики, а значит, позволяют добиться большего при выражении архитектурных идей, решении сложных задач, оптимизации и тонкой настройке кода. Знание идиом - признак свободного владения языком программирования.

Пространство идиом С++. Идиомы процедурного программирования
Идиомы С++ покрывают не вытекающие из его синтаксиса аспекты, придающие языку эффективность, совместимость с языком С и удобство использования, и допускают классификацию по таким признакам, как:
   * уровень сложности
   * степень переносимости в другие языки(из других языков)
   * отношение к парадигме программирования и т.д.
Из языка С в С++ вошли идиомы процедурного программирования:
   for(;;);          // пустой бесконечный цикл
   while(1) foo();   // цикл с тождественным истинным условием

   // постфиксный декремент, адресная арифметика и др.
   while (*cp++ = *cp2++)
   
Пространство идимо С++. Объектно-ориентированные идиомы: обзор
Объектно-ориентированные идиомы С++ охватывают все аспекты языковой поддержки парадигмы объектно-ориентированного программирования включая:
   * систему статического контроля типов времени компиляции
   * систему динамической идентификации типов времени выполнения(RTTI)
   * абстрактые и конкретные типы данных(структуры и классы)
   * управление доступом
   * инициализацию и уничтожение объектов
   * инкапсуляцию, наследование, полифорфизма подклассов
   * перегрузку операций-функций(operator =, operator <<, operator >>)
   
КЛАССЫ ИЛИ СТРУКТУРЫ?

                          Структура                  Класс
Базовая семантика         Простой агрегат(данные,    Пользовательский тип
                          вложенные типы)            (без ограничений)
Наличие конструкторов     Редко                      В большинстве случаев
и деструкторов            
Уровень доступа к         Открытые(public)           Закрытые(private)
членам по умолчанию       
Использование в           Да                         Да
шаблонах                  
Использование в           Да                         Да
иерархиях наследования    
Примеры                   std::pair<T1, T2>          std::vector<T>
                          boost::is_void<T>

ОБЪЕКТНО-ОРИЕНТИРОВАННЫЕ ИДИОМЫ С++: ПРИМЕРЫ
Тривиальные конструктор:
   * формируется автоматически
   * не инициализирует значение POD-типов
   * рекурсивно вызывается для объектов базовых классов
Конструктор(операция-функция) почленного копирования(присваивания) по умолчанию:
   * формируются автоматически
   * выполняют поверхностную инициализацию(присваивание)
Отсутствие наследование конструкторов:
   class A;
   A a;        // вызов A::A(), если есть
   A b(a)      // вызов A::A(A&), если есть
   
Инициализация и уничтожение объектов автоматической и динамической памяти
Связывание инициализации объекта с его созданием
Неявный параметр нестатических методов классов - псевдопеременная this
class A;
A *pa = new A(42);            // вызов A::A(int)
A *pa2 = new A[n];            // вызов A::A(), N раз

// освобожение памяти с вызовом A::~A()
delete [] pa2;
// освобождение памяти без вызова A::~A()
// delete pa2;

ИДИОМЫ ПОВЫШЕННОГО УРОВНЯ СЛОЖНОСТИ
Перегруженные операции, в том числе:
   * операция индексирования агрегатов: operator [] - допускает контекстно-зависимую перегрузку в зависимости от использования в лево- и праводопустимых выражениях
   * операция выделения памяти: operator new
   * операция освобождения памяти: operator delete
   * операция доступа у указателю: operator ->
   * операция приведения к POD-типам: operator double, operator char, др.
Функциональные объекты(функторы)
Подсчет ссылок и указателей - квазиавтоматическая сборка мусора из динамической памяти
Объекты переменного размера и др.

ИДИОМА №1. Контекстно-зависимая перегрузка индексирования
class ARef {      // фиктивный класс
   public:
      ARef(A &a, int i): _a(a), ix(i) {}
      // запись t в _a
      ARef& operator = (T t)     { return *this; }
      // чтение из _a в _t
      operator T()               { return _t}
private:
   A&    _a;   //ссылка на агрегат
   int  _ix;   // индекс в агрегате
   T     _t;   // T - гл. обр. базовый тип
}


class A {                  // агрегат
  friend class ARef;       // для повышения производительности
  public:
      A() { /* */ }
      ARef operator [] (int ix) { return ARef(*this, ix); }
};

// в точке использования
A a;     int i,j;       T t;
a[i] = t;      // (a.operator[](i)).operator = (t);
t = a[j];      // t = (a.operator[](j)).operator T();


ИДИОМА №2. "АВТОМАТИЧЕСКАЯ" СБОРКА МУСОРА. ПОДСЧЕТ ССЫЛОК
Операции создания и уничтожения объектов могут подвергаться оптимизиации для повышения быстродействия и эффективности использования памяти отдельными классами.
Наиболее распространненные механизмы подобной оптмизиации реализует идиома общего(разделяемого) представления и подсчета ссылок, которые:
   * обобщаются для любых классов с копированием экземпляров
   * представляют особую ценность при динамическом выделении и освобождении памяти

class StringRep {    // класс-представление
   friend class String;
private:
   StringRep(const char * p) : _count(1) {
      strcpy(_rep = new char[std:strlen(s) + 1], s);
   }
   ~StringRep() { delete [] _rep; }
private:
   char * _rep;      // общее представление
   int    _count;    // количество ссылок
}

class String {
public:
   String () { rep = new StringRep(""); }
   String (const String &s) { rep = s.rep, rep->_count++; }

   String& operator= (const String &s) {
      s.rep->_count++;
      if (--rep->count <= 0) delete rep;
      rep = s.rep;
      return *this;
   }
   ~String() { if (--rep->_count <= 0) delete rep; }
   
   String (const char * s) { rep = new StringRep(s); }
   int length() const { // делегирование
      return strlen(rep->_rep);
   }
private:
   StringRep *rep;
}

ИДИОМА №3. Управление памятью заменой операций new и delete
Вариант 1. Полный контроль над выделением и освобождением памяти(например, по соображениям эффективности или в силу отсутствия базовой поддержки) достигается переопределением глобальных операций-функций:
void* operator new    (std::size_t size);
void  operator delete (void *ptr);

// для "размещающего" new: T *pt = new(buf) T(val);
void operator new(std::size_t, void* p);

Примечание: При переопределении ::new и ::delete может потребоваться знание адреса начала области динамической памяти HEAP_BASE_ADDRESS и прочих сопутствующих констант.

Вариант 2. Контроль над выделением и освобождением памяти под объектам класса требует специализированной реализации (перегрузки) операций распределения памяти на уровне самого класса(или одного из его предков)
Преимущества перегрузки операций-функций operator new и operator delete проявляются:
   * для классов, создающих мелки объекты(от 4 до 10 байт)
   * в операционных системах с примитивами управления памятью и без них
   * в виде повышения производительности и сокращения накладных расходов на распределение отдельных блоков памяти(от 4 до 8 байт)
С учетом нужд приложения память объекта может выделяться из пула статического или динамического размера

СОЗДАНИЕ ОБЪЕКТОВ В ПУЛЕ ДИНАМИЧЕСКОГО РАЗМЕРА
class String {
public:
   String()                { /* _rep = ... */ }
   String(const char* s)   { /* _rep = ... */ }
   ~String()               { delete[] _rep; }

   void* operator new (std::size_t);
   void operator delete(void*);
private:
   static String *_list;         // список свободных блоков
   // указатель на следующий блок или представление строки
   union {
      String *_freeptr; char *_rep;
   }
}

String *String::_list = nullptr;

void String::operator delete (void *p) {
   String *s = (String*)p;
   s->_freeptr = _list;
   _list = s;
}

void* String::operator new(std::size_t /* size */) {
   if (!_list) {
      int i = 0;
      for (_list = (String*) new char[POOL_SIZE * sizeof(String)]; i < POOL_SIZE - 1; i++)
         _list[i]->_freeptr = &(_list[i + 1]);
      _list[i]->_freeptr = nullptr;
   }
   String *aList = _list;
   _list = _list->freeptr;
   return aList;
}

РЕФАКТОРИН ИСХОДНОГО КОДА
Рефакторинг - систематическая(технологическая) дятельность по изменению внутренней структуры ПО, цель которой:
   * облегчить понимание работы исходного кода, - а значит, облегчить обнаружение ошибок
   * упростить модификацию кода без изменения наблюдаемого поведения
   * улучшить композицию ПО и ускорить написание кода
Преимущества:
   * предсказуемость результата каждого шага
   * продолжение проектирования во время разработки(сопровождение)
   * повышение скорости внесения изменений и реализации новых функций
   * поддержка качества при продолжении разработки
Ключевые риски:
   * необходимость внесения изменений в работающий код
   * необходимость(в ряде случаев) изменения интерфейсов

Рефакторинг ОО-кода и правила ОО-проектирования
Б.Фут(Brian Foote) и У.Опдайк(William Opdyke) в работе Life Cycle and Refactoring Patterns that Support Evolution and Reuse(1995) указали на ряд правил ОО-проектирования, многие из которых перекликаются с каталогами методов рефакторинга из книги М.Фаулера:
   * DR1. Use Consistent Names
   * DR2. Eliminate Case Analysis
   * DR3. Reduce the Number of Arguments
   * DR4. Reduce the Number of Methods
   * DR7. Minimize Access to Variables
   * DR8. Subclasses Should Be Specializations
   * DR9. Split Large Classes
   * DR11. Separate Methods That Do not Communicate

Статический анализ и инспекция кода.
Статический анализ кода:
   * предшествует и сопровождает его рефакторинг
   * в отличие от традиционных практик тестирования проводится без реального выполнения объекта исследования, вручную или специальными инструментами
К числу ошибок, выявляемых при статическом анализе кода, относятся:
   * неверное или неопределенное поведение - обращение к неинициализированным переменным, "пустым" указателям и др.
   * использование небезопасных функций(например, gets())
   * переполнение буфера
   * нарушение кроссплатформенности
   * нарушение зон ответственности классов
   * выхов функций(методов) как процедур и т.д.

Персональная оценка(инспекций) - статический анализ кода без применения инструментальных средств для опредеелния
   * эффективности (использования ресурсов, вычислительной сложности)
   * удобства сопровождения(анализ, проверки, внесения изменений)
   * надежности(зрелости, способности к восстановлению после сбоев)
   * иных структурных показателей качества(напр. по ГОСТ Р ИСО 9126)
Основные правила персональной оценки являются:
   * регулярность - представление отчета о проведении на каждом техническом совете(напр. еженедельно)
   * независимость - назначение рецензентов из числа членов команды, не являющихся первоначальными владельцами кода
   * вовлечение - распространение знаний о каждом (не)удачном фрагменте кода среди всех членов команды
   * управление - назначение ответственности и сроков исправления

ЭФФЕКТИВНОСТЬ СТАТИЧЕСКОГО АНАЛИЗА
>65% ошибок: Совокупность пересмотров дизайна и испекции кода иногда превышает 90%
30% ошибок:  Снижение расходов и сокращение периода разработки благодаря пересмотрам, испекции/статическому анализу и технологиям виртуализации.
Статичекий анализ позволяет избежать возникновения "периода хаоса" в начале эксплуатации и обнаружить дефекты на тех стадиях разработки, когда они возникают.

ПЕРЕСМОТРЫ и ЭФФЕКТИВНОСТЬ СНИЖЕНИЯ ДЕФЕКТОЕМКОСТИ КОДА
Вид пересмотра                                           Мин. %         Медиана,%      Макс, %
Пересмотр архитектуры верхнего уровня                    30                40          60
Детальный пересмотр "функциональной архитектуры"         30                45          65
Детальный пересмотр "логической архитектуры"             35                55          75
Статический анализ / Инспекция кода                      35                60          85

По данным обзора: Jones, C. Software Quality in 2010: A Survey of the State of the Art

Типовые анти-шаблоны и "грязные техники"
Инспекция кода способствует обнаружению неудачных решений задач проектирования, проявляющих себя как использование так называемых "анти-шаблонов" дизайна и "грязных техник" (dirty coding) программирования, например:
   * "божественный" объект (God object) - объект(класс) с чрезмерной функциональной нагрузкой; монолит, замыкающий на себе чересчур много каналов взаимодействия прочих элементов архитектуры
   * магические числа (magic numbers) - константы с трудно постижимой семантикой
   * "жесткий код" (hard code) - имена, адреса и пр. числовые и символьные литералы, наличие которых затрудняет или делает невозможным конфигурирование системы
   * загадочный код(cryptic code) - умышленное или неумышленное несоблюдение принципа самодокументируемости исходного кода
   * проверка типа вместо интерфейса(checking type instead of interface) - нарушение принципа Programming to Interfaces
   * "мертвый" или пустой код(dead or empty code) - кодовые фрагменты, которые не используются в текуущий сборке(версии) приложения, устарели или сделаны "про запас"
   * архитектурно необоснованные заглушки(stub code) - методы или функции, не выполняющие роль пустых неабстрактных методов, шаблонных методов(GoF) или операций-"зацепок"
   * код с непредсказуемым поведением (unpredictable code) - обращение к неинициализированным переменным, "трюки" в управлении памятью, неконтролируемое переполнение буферов и пр.
   
   
ТИПОВЫЕ ЛОГИКО-СЕМАНТИЧЕСКИЕ ОШИБКИ В ПРОГРАММНОМ КОДЕ
К числу ошибок в исходном коде на любом ОО-языке, в том числе С++, следует отнести:
   * неверную обработку краевых условий(например, замену <= на <)
   * неверную реализацию применяемых алгоритмов
   * неверный способ передачи параметров
   * опечатки в именах перегружаемых методов
   * неправильную обработку исключений(в том числе пустые обработчики)
   * несоблюдение принципов транзакционной обработки данных(ACID - atomicity, consistency, isolation, [and] durability)
   * допущение нежелательного параллельного доступа нескольких потоков к разделяемым данным
   * компрометацию уровней доступа к членам классов и уровней приложения
   * неверную обработку "пустых" указателей
   
   
АКТУАЛЬНОСТЬ ПРОБЛЕМ КАЧЕСТВА ПО
Актуальность проблематики качества ПО обусловлена рядом объективных факторов эволюции индустрии разрабокти ПО, в том числе:
   * развитием новых итераторых методов разработки
   * распространение методов обеспечения и контроля качества ПО на все этапы разработки продуктов
   * распространением методов ОО-анализа, проектирования и разработки
   * широким применением формальных языков моделирования (UML) и CASE-технологий
   
ПОНЯТИЕ КАЧЕСТВА. ЧТО ТАКОЕ "КАЧЕСТВЕННОЕ ПО"?
СОгласно стандарту ГОСТ Р ИСО 9000, качество - это "степень соответствия присущих характеристик (отличительных свойств) изделия или продукта потребления, ожиданиям"
В программного инженерии различают качество ПО и качество исходного кода(с точки зрения человека или машины?!)
Необходимость управления качеством обусловлена потребностью управлять (повышать качество управления) рисками и затратами на всех эатах жизненного цикла ПО
   
ФУНКЦИОНАЛЬНЫЕ И СТРУКТУРНЫЕ ПОКАЗАТЕЛИ КАЧЕСТВА КОДА
Различают функциональные и структурные показатели качества:
   * функциональные - отражают степерь соответствия продукта требованиям к его функции, техническому проекту, спецификации
   * структурные - описывают соответствие ПО требованиям к архитектуре(организации) и характеризуют надежность, удобство сопровождения и т.д.
Квалифицированная оценка "структурного качества" ПО предполагает высокоуровневый статический анализ архитектуры продукта (в том числе компонентной структуры, используемой платформы и схемы БД), а также исходного программного кода
   
   
КАЧЕСТВО ПО СОГЛАСНО ISO 9126
Стандартная на сегодняшний день модель качества ПО принята в 1991 г. и закреплена стандартом ISO 9126:
   * Введен в РФ как ГОСТ Р ИСО/МЭК 9126-93 "Информационная технология. Оценка программной продукции. Характеристики качества и руководства по их применению"
Модель ISO 9126 оперирует 3 категориями:
   * цели(goals) - ожидания от ПО
   * атрибуты(attributes) - свойства ПО: показывают близость к достижению целей
   * метрики(metrics) - количественные оценки меры наличия атрибутов
В модель ISO 9126 выделено 6 целей, достижение которых определяется 21 атрибутом

ЖЕЛАЕМЫЕ СТРУКТУРНЫЕ ХАРАКТЕРИСТИКИ ПО
Посвященный вопросам качества продуктов стандарт ISO/IEC 9126-3 дополняют стандарты ISO/IEC 250x0, которые вводят в рассмотрение практическую модель качества SQuaRE
   
ЦЕЛИ И МОДЕЛИ КАЧЕСТВА ISO 9126 И ХАРАКТЕРИСТИКИ SQuaRE
   * Efficency          - эффективность
   * Functionality      - функциональность
   * Maintainability    - удобство сопровождения
   * Portability        - переносимость
   * Reliability        - надежность
   * Usability          - удобство использования
   
МОДЕЛЬ SQuaRE: НАДЕЖНОСТЬ
Надежность - показатель прочности и устойчивости системы, отражающий степерь риска, связанного с использованием системы, и вероятность возникновения в ней сбоев
Оценка и мониторинг надежности позволяют предотвратить простои системы(или сократить продолжительность таковых), а также снизить частоту появления ошибок, влияющих напрямую на пользователей.

МОДЕЛЬ SQuare: ЭФФЕКТИВНОСТЬ
Эффективность - один из ключевых показателей для высокопроизводительных и высоконагруженных систем с высокой алгоритмической сложостью и массовыми транзакциями. Оценка эффективности предполагает рассмотрение, в том числе:
   * производительности операций доступа и управления данными
   * управление памятью, сетевыми и дисковыми ресурсами
   * соблюдение правил кодирования: ЯВУ, SQL
   
МОДЕЛЬ SQuaRE: БЕЗОПАСНОСТЬ
Критерий безопасности показывается, насколько вероятно обнаружение критических уязвимостей и нарушение(взлом) защиты системы по причине некачественного написание кода или неудачной архитектуры, и учитывает:
   * соблюдение правил кодирования наиболее уязвимых мест(проверка ввода, защита от SQL-инъекций, доступ к системным функциям и т.д.)
   * корректную обработку ошибок и исключений
   
МОДЕЛЬ SQuaRE: УДОБСТВО СОПРОВОЖДЕНИЯ
Критерий удобства сопровождения дает интегральную оценку возможности адаптации, переноса системы на другую платформу и передачи проекта между командами разработчиками. Его оценка предполагает, в числе прочего, анализ:
   * наличия документации и удобства чтения исходного кода
   * сложности транзакций и алгоритмов
   * применения "грязных" техник
   * связности и переносимости кода
   
МОДЕЛЬ SQuaRE: РАЗМЕР КОДА
Не будучи в буквальном смысле показателем качества, размер исходного кода влияет на возможность сопровождения системы и позволяет оценить трудозатраты на разработку в ретроспективе ("что сделано?") и перспективе ("что предстоит сделать?")
Размер продукта оценивается, к примеру:
   * по количеству строк исходного кода(SLOC - source line of code)
   * по количеству артефактов (файлов, пакетов, классов, методов, таблиц и т.д.)
   
УПРАВЛЕНИЕ СЛОЖНОСТЬЮ ИСХОДНОГО КОДА. ВЛИЯНИЕ МОДУЛЬНОСТИ
Практическую ценность представляет опосредованное восприятие сложности ПО участниками проекта по разработке через набор легко вычислимх или наглядных метрик и артефактов:
   * количество, размер и связность единиц трансляции
   * соблюдение общепринятых правил ОО-проектирования
   * соблюдение соглашений о моделировании, кодировании
"Несложный" код отличают:
   * локаничность
   * модульность
   * слабая связность
   * использование архитектурных шаблонов
   * соблюдение правил оформления кода
   * систематическая обработка ошибок
   
ПРЕДВАРИТЕЛЬНОЕ ПРОЕКТИРОВАНИЕ И СЛОЖНОСТЬ КОДА
Снижение сложности ПО способствует предварительное проектирование с целью разработки архитектуры(дизайна) в соответствии с заданным критериями качества и с учетом ее резализуемости в выбранном языке.
Критерии качества архитектуры, как правило обеспечивают:
   * возможность повторного использования
   * гибкость настройки
   * расширяемость и переносимость
   * структурированность и модульность
   * понятность и простоту(в том числе взаимодействие компонентов)
   
"ТЕХНИЧЕСКИЙ ДОЛГ": ЕГО НАКОПЛЕНИЕ И СНИЖЕНИЕ
"Технический долг"(technical debt) - метафора, введенная У. Каннингемом(Ward Cunningham) для обозначения:
   * временных архитектурных решений
   * применение устаревших или устаревающих технологий
   * требующий устранения ошибок и "мертвого" кода
   * нереализованных тестов
   * не выполненных работ по рефакторингу продукта
Накоплению технического долго способствуют:
   * длительность разработки(несколько лет)
   * раздробленность коллектива разработчиков на небольшие команды
Стратегия снижения технического долга предполагают:
   * формирование выделенносй команды
   * введение "технического налога"
   
СТАНДАРТЫ И СТИЛИ КОДА
Стандарты и руководства по стилю оформления ОО исходного программного кода:
   * закрепляют эмпирические правила организации исходного кода
   * отражают многолетний опыт практического программирования многих специалистов
   * описывают рекомендуемое применение идиоматики языка программирования
   * обеспечивают еденый стиль оформление классов
   * помогают стправиться с сложностью классов в процессе развития программы
   
СОГЛАШЕНИЕ О КОДИРОВАНИИ И ЕГО РОЛЬ В КОМАНДНОЙ РАЗРАБОТКЕ ПО
Соглашение о кодировании(coding standart) - документ:
   * регламентирующий подходы к оформлению исходного кода на языке высокого уровня или ручной верстки языке разметки
   *(опционально) имеющий статус локального правового акта организации
   * действующий в рамках организации или проектного офиса(реже - отдельного проекта или проектов)
Преимущества заключения соглашения о кодировании:
   * легкость включения в проект разработки новых специалистов
   * удобство чтения и простота понимания и испекции исходного кода
   * формирование важных в командной разработке навыков и привычек оформления результатов труда
   * легкость трассировки изменений и ручного контроля версий
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   