СТАНДАРТНАЯ БИБЛИОТЕКА ШАБЛОНОВ(STL): ИСТОРИЯ СОЗДАНИЯ
Стандартная библиотека шаблонов(Standart Templates Library, STL) была задумана в 1970-х - 1990-ч гг. А. Степановым, Д. Мюссером(D.Musser) и др. как первая универсальная библиотека обобщенных алгоритмов и структур данных и в качестве составной части стандартной библиотеки языка С++ является воплощением результатов изысканий в области теоретической информатики

ПРЕДПОСЛЫКИ СОЗДАНИЯ STL
По словам А.Степанова, наибольшее значение при создании STL придавалось следующим фундаментальным идеям:
   * обобщенному программированию как дисциплине, посвященной построению многократно используемых алгоритмов, структур данных, механизмов распределения памяти и др.
   * достижению высокого уровня абстракции без потери производительности.
   * следованию фон-неймановской модели(в первую очередь - в работе с базовыми числовыми типами данных при эффективной реализации парадигмы процедурного программирования, а не программирования "в математических функциях")
   * использованию семантики передачи объектов по значению
   
СОСТАВ STL
Концептуально в состав STL входят:
   * обобщенные контейнеры(универсальные структуры данных) - векторы, списки, множества и т.д.
   * обобщенные алгоритмы решения типовых задач поиска, сортировки, вставки, удаления данных и т.д.
   * итераторы(абстрактные методы доступа к данным), являющиеся обобщением указателей и реализующие операции доступа алгоритмов к контейрам
   * функциональные объекты, в объектно-ориентированнм ключе обобщающие понятия функции
   * адаптеры, модифицирующие интерфейсы контейнеров, итераторов, функций
   * распределители памяти
   
   
КОНТЕЙНЕРЫ: ОБЗОР
Контейрены STL - объекты, предназначенные для хранения коллекций другиех объектов, в том числе и контейнеров

ПОСЛЕДОВАТЕЛЬНЫЕ КОНТЕЙНЕРЫ
Последовательные контейнеры STL хранят коллекции объектов одного типа Т, обеспечивая их строгое линейное упорядочивание.
Вектор - динамический массив типа std::vector<T>, характеризуется произвольным доступом и автоматическим изменением размера при добавлении и удалении элементов
Дек(двусторонняя очередь, deque - double-ended queue) - аналог вектора типа std::deque<T> c возможностью быстрой вставки и удаления элементов в начале и конце контейнера
Список - контейнер типа std::list<T>, обеспечивающий константное время вставки и удаления в любой точке, но отличающийся линейным временем доступа.

Примечание: Последовательными контейнерами STL в большинстве случаев могут считаться массив T a[N] и класс std::string

УПОРЯДОЧЕННЫЕ АССОЦИАТИВНЫЕ КОНТЕЙНЕРЫ
Упорядоченные ассоциативные контейнеры STL представляют возможность быстрого доступа к объектам коллекции переменной длины, основанных на работе с ключами
Множество - контейнер типа std::set<T> c поддержкой уникальности ключей и быстрым доступом к ним. Мультимножество - аналогичный множеству контейнер типа std::multimap<T> c возможностью размещения в  нем ключей кратности 2 и выше.
Отображение - контейнер типа std::map<Key, T> с поддержкой уникальных ключей типа Key и быстрым доступом по ключам к значениям типа Т. Мультиотображение - аналогичным отображению контейнер типа std::multimap<Key, T> с возможностью размещенияя в нем пар значений с ключами кратности 2 и выше.

ВЕКТОРЫ: ОБЩИЕ СВЕДЕНИЯ
Вектор - последовательный контейнер
   * переменной длины
   * с произвольным доступом к элементам
   * с быстрой вставкой и удалением элементов в конце контейнера
   * с частичной гарантией сохранения корректности итераторов после вставки и удаления
Технически вектор STL реализован как шаблон с параметрами вида:
// 1-й параметр - тип данных, 2-й распределитель памяти
template<typename T, typename Allocator = std::allocator<T> >

ДЕКИ: ОБЩИЕ СВЕДЕНИЯ
Дек - последовательный контейнер
   * переменной длины
   * с произвольным доступом к элементам
   * с быстрой вставкой и удалением элементов в начале и конце контейнера
   * без гарантии сохранения корректности итераторов после вставки и удаления
Технически дек реализован как шаблон с параметрами вида:
template<typename T, typename Allocator = std::allocator<T> >
Предоставляемые встроенные типы и порядок конструкции аналогичны таковым для контейнера std::vector<T>

СПИСКИ: ОБЩИЕ СВЕДЕНИЯ
Список - последовательный контейнер
   * переменной длины
   * с двунаправленными итераторами для доступа к элементам
   * с быстрой вставкой и удалением элементов в любой позиции
   * со строгой гарантией сохранения корректности итераторов после вставки и удаления
Технически список реализован как шаблон с параметрами вида:
template<typename T, typename Allocator = std::allocator<T>>

Предоставляемые встроенные типы и порядок конструкции аналогичны таковым для контейнера std::vector<T>

МНОЖЕСТВА И МУЛЬТИМНОЖЕСТВА: ОБЩИЕ СВЕДЕНИЯ
Множества, мультимножества - упорядоченные ассоциативные контейнеры
   * переменной длины
   * с двунаправленными итераторами для доступа к элементам
   * с логарифмическим временем доступа
Технически множества и мультимножества STL реализованы как шаблоны с параметрами вида:
// 1-ый пар. - тип ключа, 2-й - функция сравнения
template<typename Key, typename Compare = std::less<Key>, typename Allocator = std::allocator<Key>>

ОТОБРАЖЕНИЯ И МУЛЬТИОТОБРАЖЕНИЯ: ОБЩИЕ СВЕДЕНИЯ
Отображения, мультиотображения - упорядоченныме ассоциативные контейнеры переменной длины:
   * моделирующие структуры данных типа "ассоциативный массив с (не)числовой индексацией"
   * с двунаправленными итераторами для доступа к элементам
   * с логарифмическим временем доступа
Технически отображения и мультиотображения STL реализованы как шаблоны с параметрами вида:
// 1-ый, 2 пар - тип ключа и связанных данных,
// 3-й - функция сравнения
template <typename Key, typename T, typename Compare=std::less<Key>, typename Allocator=std::allocator<std::pair<const Key, T>>>


ОБОБЩЕННЫЕ АЛГОРИТМЫ: ОБЗОР
Обобщенные алгоритмы STL предназначены для эффективной обработки обобщенных контейнеров и делятся на четыре основных группы:
Последовательные алгоритмы: немодифицирующие, модифицирующие
Алгоритмы упорядочивания
Алгоритмы на числах

ПОСЛЕДОВАТЕЛЬНЫЕ АЛГОРИТМЫ
Немодифицирующие последовательные алгоритмы - не изменяют содержимое контейнера-параметра и решают задачи поиска перебором, подсчета элементов и установления равенства двух контейнеров.
Например: std::find(), std::equal(), std::count()

Модифицирующие последовательные алгоритмы - изменют содержимое контейрена-параметра, решая задачи копирования, замены, удаления, размещения, перестановки значений и пр.
Например: std::copy(), std::random_shuffle(), std::replace()

АЛГОРИТМЫ УПОРЯДОЧИВАНИЯ. АЛГОРИТМЫ НА ЧИСЛАХ
Алгоритмы упорядочивания - все алгоритмы STL, работа которых опирается на наличие или установление отношения порядка на элементах. К данной категории относятся алгоритмы сортировки и слияния последовательностей, бинарного поиска, а также теоретико-множественные операции на упорядоченных структурах
Например: std::sort(), std::binary_search(), std::set_union()

Алгоритмы на числах - алгоритмы обобщенного накопления, вычисления нарастающего итога, попарных разностей и скалярных произведений.
Например: std::accumulate(), std::partial_sum(), std::inner_product()

КОПИРУЮЩИЕ, ПРЕДИКАТНЫЕ И АЛГОРИТМЫ, РАБОТАЮЩИЕ НА МЕСТЕ
Среди обобщенных алгоритмов STL выделяют:
   * работающие на месте - размещают результаты поверх исходных значений, которые при этом безвозвратно теряются.
   * копирующие - размещают результат в других контейнерах или не перекрывающей входные значения области того же контейнера.
   * принимающие функциональный параметр - допускают передачу на вход(обобщенной) функции с одним или двумя параметрами.

Наибольшее значение среди функций, принимаемых на вход обобщенными алгоритмами, имеют следующие:
   * обобщенная функция двух аргументов типа T, возвращающая значение типа T. Может наследоваться от std::binary_function<T, T, T>
   * обобщенная логическая функция(предикат) одного аргумента, может наследоваться от std::unary_function<T, bool>
   * обобщенная логическая функция(предикат) двух аргументов, может наследоваться от std::binary_function<T, T, bool>

ОТНОШЕНИЕ СРАВНЕНИЯ
Использумые в обобщенных алгоритмах STL отношения сравнения формально являются бинарным предикатом, к которым - для получения от алгоритмов предсказуемых результатов - предъявляется ряд требований. Так если отношение сравнения R определяется на множестве S, достаточно(но более, чем необходимо), чтобы:
   * для всех x,y,z из S имело бы утверждение: xRy ^ yRz => xRz
   * для всех x,y,z из S имелоб быть тоолько одно из следующих утверждений: xRy или yRx или x = y
   
Отвечающее указанным требования отношения сравнения являются строгим полным порядком и реализуется например:
   * операцией < над базовыми типами языка С++
   * операцией-функцией operator < () класса std::string
   * входящим в STL предикатным фунциональным объектом std::less<T>

Необходимым условием применимости бинарного предиката R как отношения сравнения в алгоритмах STL является допущение о том, что элементы x,y из S, для которых одновременно наверны утверждения xRy, yRx, x=y, тем не менее признаются эквивалентными(по отношению R - строгий слабый порядок).
В этом случае любые два элемента, взаимное расположение которых по отношению R не определено, объявляются эквивалентными.
Примечание: такая трактовка эквивалентности не предполагает никаких суждений относительно равенства элементов, устанавливаемого операцией сравнения ==.
   * Напривер сравнения строк без учета регистроа символов

ОБРАТНЫЕ ОТНОШЕНИЯ
При необходимости отношения C, обратное R на множестве S, такое, что xCy <=> yRx, может быть смоделировано средствами STL.
Так, при наличии operator<() для произвольного типа Т обратное отношение определяется реализованнмым в STL шаблоном обобщенной функции сравнения вида:
template<typename T>
inline bool operator > (const T& x, const T& y) {
   return y < x;
}
Для удобства использования данная функция инкапсулирована в предикатный функциональный объект std::greater<T>();
   
АЛГОРИТМЫ СОРТИРОВКИ
std::sort
   Нестабильная сортировка на месте(вариант quicksort) в среднем за O(NlogN)
   Наиб. время: O(N*N)
std::partitial_sort
   Нестабильная сортировка на месте(вариант heapsort; допускает получение отсортир. поддиапазона длины k)
   Наиб. время: O(NlogN) или O(NlogK)
std::stable_sort
   Стабильная сортировка на месте (вариант mergesort, адаптируется к ограничениям по памяти, оптимально - наличие памяти под N/2 элементов)
   Наиб. время: от O(NlogN) до O(N(logN)^2) (при отсутствии памяти)

ОПЕРАЦИИ НАД МНОЖЕСТВАМИ И ХИПАМИ: ОБЗОР
Реализуемые обобщенными алгоритмами STL операции над множествами имеют традиционное теоретико-множественное значение и выполняются над отсортированными диапазонами, находящимися в любых контейнерах STL
В дополнение к прочим STL вводит в рассмотрение такую структуру данных, как хип. Хип(max heap) - порядок организации данных в спроизвольным доступом к элементам в диапазоне итераторов [a; b), при котором:
   * значение, на которое указывает итератор а, является наибольшим в диапазоне и может быть удалено из хипа операцией извлечения(pop), а новое значение - добавлено в хип за время O(logN) операцией размещения (push)
   * результатоами опреации push и pop является корректные хипы.

ИТЕРАТОРЫ: ОБЗОР
Итераторы(обобщенные указатели) - объекты, предназначенные для обхода последовательности объектов в обобщенном контейнере. В контейнерных классах являются вложенными типами данных.

Итераторы STL:
   * Входные: входные потоковые
   * Выходные: выходные потоковые
   * Однонаправленные
   * Произвольного доступа
   * Двунаправленные

ВСТРОЕННЫЕ УКАЗАТЕЛИ С++
Встроенные типизированные указатели С++ по своим возможностям эквивалентны итераторам произвольного доступа и могут использоваться как таковые в любом из обобщенных алгоритмов STL
const int N = 100;
int a[N], b[N];
std::copy(&a[0], &a[N], &b[0]);
std::replace(&a[0], &a[N/2], 0, 42)

ИТЕРАТОРЫ В СТАНДАРТНЫХ КОНТЕЙНЕРАХ: ОБЩИЕ СВЕДЕНИЕ
Шаблоны классов контейнеров STL содержат определения следующих типов итераторов:
   * изменяемый итератор прямого доступа(допускает преобразование к константому итератору(см. ниже); *i - ссылка)
      Container<T>::iterator
   * константный итератор прямого обхода(*i - константная ссылка)
      Container<T>::const_iterator
   * изменяемый итератор обратного обхода
      Container<T>::reverse_iterator
   * константный итератор обработного обхода:
      Container<T>::const_reverse_iterator


ИТЕРАТОРЫ ВСТАВКИ
Итераторы вставки "переводят" обобщенные алгоритмы из "режима замены" в "режим вставки", при котором разыменовывание итератора *i влечет за собой добавление элемента при помощи одного из предоставляемых контейнером методов вставки.
С технической точки зрения, реализованные в STL итераторы вставки являются шаблонами классов, единственными параметром который является контейнерный тип Container:
   * std::back_insert_iterator<Container> - использует метод класса Container::push_back()
   * std::front_insert_iterator<Container> - использует метод класса Container::push_front();
   * std::insert_iterator<Container> - использует метод класса Container::insert();

Пратическое использование итераторов вставки, формируемых "на лету" упрощает применением шаблонов обобщенных функций std::back_inserter(), std::front_inserter() и std::inserter() вида:
template<typename Container>
inline std::back_insert_iterator<Container>
back_inserter(Container &c) {
   return std::back_insert_iterator<Container>(c);
}

std::copy(list1.begin(), list1.end(),
         back_inserter(vector1));
      // back_insert_iterator<std::vector<int> >(vector1));

ПОТОКОВЫЕ ИТЕРАТОРЫ
Потоковые итераторы STL предназначены для обеспечения работы обобщенных алгоритмов со стандартными потоками ввода-вывода. Технически представляют собой шаблоны классов:
   * std::istream_iterator<T> - входной потоковый итератор
   * std::ostream_iterator<T> - выходной потоковый итератор
Конструкторы:
   * std::istream_iterator<T>(std::istream&) - входной итератор для чтения значений типа T из заданного входного потока
   * std::istream_iterator<T>() - входной итератор - маркер "конец потока" (EOS, end-of-stream)
   * std::ostream_iterator<T>(std::ostream&, char*) - выходной итератор для записи значений типа T в заданный выходной поток через указанный разделитель.

ПРИМЕР: ПОТОКОВЫЙ ИТЕРАТОР; ОБОБЩЕННЫЙ АЛГОРИТМ find
// 3-й и 4-ый ар. - рабочий итератор и end-of-stream(EOS)
std::merge(vector1.begin(), vector1.end(),
           std::istream_iterator<int>(std::cin),
           std::istream_iterator<int>(),
           std::back_inserter(list1));

template<typename InputIterator, typename T>
InputIterator find(                       // поиск перебором
                   InputIterator first,   // начало диапазона
                   InputIterator last,    // конец диапазона
                   const T& value) {      // значение
   while(first != last && *first != value)
      ++first;
   return first;
}

template <typename InputIterator,
          typename OutputIterator>
OutputIterator copy(InputIterator  first,
                    InputIterator  last,
                    OutputIterator result) {
   while(first != last) {
      *result = *first;
      ++first;
      ++result;
   }
   return result;
}

template<typename ForwardIterator, typename T>
void replace(ForwardIterator first,
             ForwardIterator last,
             const T& x, const T& y) {
   while(first != last) {
      if (*first == x)
         *first = y;
      ++first;
   }
}

ФУНЦИОНАЛЬНЫЕ ОБЪЕКТЫ: ОБЗОР:
Функциональные объекты((обобщенные функции) - программыне компоненты, применимые к известному количеству фактических параметров(число 0 и более) для получения значения или изменения состояния вычислительной системы
STL-расширением функции является пользовательский объект типа класса (class) или структуры(struct) с перегруженной операцией-функцией operator().
Базовыми классами стандартных функциональных объектов STL выступают шаблоны структур std::unary_function и std:binary_function.

template<typename Arg, typename Result>
struct unary_function {
   typedef Arg    argument_type;
   typedef Result result_type;
};

template <typename Arg1, typename Arg2, typename Result>
struct binary_function {
   typedef Arg1   first_argument_type;
   typedef Arg2   second_argumnet_type;
   typedef Result result_type;
}

СТАНДАРТНЫЕ ФУНКЦИОНАЛЬНЫЕ ОБЪЕКТЫ STL
// для арифметический операций
template<typename T> struct plus;            // сложение
template<typename T> struct minus;           // вычитание
template<typename T> struct multiplies;      // умножение
template<typename T> struct divides;         // деление
template<typename T> struct modulus;         // остаток
template<typename T> struct negative;        // инверсия знака

// для операции сравнения
template<typename T> struct equal_to;        // равно
template<typename T> struct not_equal_to;    // не равно
template<typename T> struct greater;         // больше
template<typename T> struct less;            // меньше
template<typename T> struct greater_equal;   // больше или равно
template<typename T> struct less_equal;      // меньше или равно

// для логических операций
template<typename T> struct logical_and;     // конъюнкция
template<typename T> struct logical_or;      // дизъюнкция
template<typename T> struct logical_not;     // отрицание

ПРИМЕР: ФУНКЦИОНАЛЬНЫЙ ОБЪЕКТ multiplies
template<typename T>
class multiplies: public binary_function<T, T, T> {
   public:
      T operator() (const T& x, const T& y) const {
         return x * y;
      }
}

АДАПТЕРЫ: ОБЗОР
Адаптеры модифицируют интерфейс других компонентов STL и технически представляют собой шаблоны классов, конкретизируемые шаблонами контейнеров, итераторов и др.
Адаптеры STL:
   Контейнерные:
      Стек
      Очередь:
         Очередь с приоритетами
   Итераторные:
      Реверсный итератор
   Функциональные:
      Связывающие
      Для указателей на функцию
      Отрицающие

КОНТЕЙНЕРНЫЕ АДАПТЕРЫ
С технической точки зрания, контейнерные адаптеры STL являются шаблонами классов, конкретизируемыми типами хранимых в них элементов и несущих последовательных контейнеров(адаптер std::priority_queue требует также функции сравнения, по умолчанию - std::less<T>).
Адаптер std::stack допускает конкретизацию вида:
   * std::stack<T> (эквивалентно std::stack<T, std::deque<T>>)
   * std::stack<T, std::vector<T>>
   * std::stack<T, std::list<T>>
Адаптер std::queue допускает конкретизацию вида:
   * std::queue<T>(эквивалентно std::queue<T, std::queue<T>>)
   * std::queue<T, std::deque<T>>
Адаптер priority_queue допускает конкретизацию вида:
   * std::priority_queue<T> (эквивалентно std::priority_queue<T, std::vector<T>, std::less<T>>)
   * std::priority_queue<T, std::deque<T>, std::greater<T>>


ФУНКЦИОНАЛЬНЫЕ АДАПТЕРЫ
Функциональные адаптеры решают задачу конструирования новых функций из существующих и технически представляют собой шаблоны фнукций и классов
Набольшее практическое значение имеют следующие адаптеры:
   * связывающие - устанавливают в константу значение первого (std::bind1st() или второго std::bind2nd()) параметра заданной бинарной функции
   * отрицающие - инверсируют результат унарного (std::not1()) или бинарного(std::not2()) предиката

std::vector<int>::iterator *where = 
   std::find_if(vector1.begin(), vector1.end(),
               std::bind2nd(std::greater<int>(), 100));
   // std::not1(std::bind2nd(std::greater<int(), 100>));

STL в С++11: КОНТЕЙНЕРЫ
Последовательные контейнеры:
   std::array<T, N> - массив значений типа T из N элементов
   std::forward_list<T, Allocator> - однонаправленный(в отличие от std::list) список элементов с "полезной нагрузкой" типа T и дисциплиной распределения памяти, заданной распредителем Allocator
Неупорядоченные ассоциативные контейнеры:
   * std::unordered_set<Key, Hash, KeyEqual, Allocator> - набор неповторяющихся объектов типа Key c амортизированным константным временем поиска, вставки и удаления(контейнер для хранения повторяющихся объектов - std::unordered_multiset)
   * std::unordered_map<Key, T, Hash, KeyEqual, Allocator> - набор пар "ключ-значение" с уникальными ключами типа Key с амортизированным константным временем поиска, вставки и удаления(контейнер для хранения пар с неуникальными ключами - std::unordered_multimap)

STL в С++11: АЛГОРИТМЫ
Набор алгоритмов STL расширен такими новыми элементами, как:
   * немодифицирующие последовательные алгоритмы: std::all_of(), std::any_of(), std::none_of(), std::find_if_not()
   * модифицирующие последовательные алгоритмы: std::copy_if(), std::copy_n(), std::move(), std::move_backward(), std::shuffle();
   * алгоритмы разбиения: std::is_partitioned(), std::partition_copy(), std::partition_point()
   * алгоритмы сортировки: std::is_sorted, std::is_sorted_until()
   * алгоритмы на хипах: std::is_heap(), std::is_heap_until()
   * алгоритмы поиска набольших и наименьших: std::minmax(), std::minmax_element(), std::is_permutation();
   * алгоритмы на числах: std::iota()
   
STL в С++11: ПРОЧИЕ ЭЛЕМЕНТЫ
Наконец, новыми элементами С++11 являются:
   * std::move_iterator<Iterator> - итератор переноса формируемых перегруженной функцией std::move_iterator<Iterator>();
   * std::next<ForwardIterator>(), std::prev<BidirectionalIterator>() - функции инкремента и декремента итераторов
   * std::begin<Container>(), std::end<Container>() - функции возврата итераторов в начало или конец контейнера или массива.
