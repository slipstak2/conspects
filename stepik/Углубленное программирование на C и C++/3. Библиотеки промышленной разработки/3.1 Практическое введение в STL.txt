СТАНДАРТНАЯ БИБЛИОТЕКА ШАБЛОНОВ(STL): ИСТОРИЯ СОЗДАНИЯ
Стандартная библиотека шаблонов(Standart Templates Library, STL) была задумана в 1970-х - 1990-ч гг. А. Степановым, Д. Мюссером(D.Musser) и др. как первая универсальная библиотека обобщенных алгоритмов и структур данных и в качестве составной части стандартной библиотеки языка С++ является воплощением результатов изысканий в области теоретической информатики

ПРЕДПОСЛЫКИ СОЗДАНИЯ STL
По словам А.Степанова, наибольшее значение при создании STL придавалось следующим фундаментальным идеям:
   * обобщенному программированию как дисциплине, посвященной построению многократно используемых алгоритмов, структур данных, механизмов распределения памяти и др.
   * достижению высокого уровня абстракции без потери производительности.
   * следованию фон-неймановской модели(в первую очередь - в работе с базовыми числовыми типами данных при эффективной реализации парадигмы процедурного программирования, а не программирования "в математических функциях")
   * использованию семантики передачи объектов по значению
   
СОСТАВ STL
Концептуально в состав STL входят:
   * обобщенные контейнеры(универсальные структуры данных) - векторы, списки, множества и т.д.
   * обобщенные алгоритмы решения типовых задач поиска, сортировки, вставки, удаления данных и т.д.
   * итераторы(абстрактные методы доступа к данным), являющиеся обобщением указателей и реализующие операции доступа алгоритмов к контейрам
   * функциональные объекты, в объектно-ориентированнм ключе обобщающие понятия функции
   * адаптеры, модифицирующие интерфейсы контейнеров, итераторов, функций
   * распределители памяти
   
   
КОНТЕЙНЕРЫ: ОБЗОР
Контейрены STL - объекты, предназначенные для хранения коллекций другиех объектов, в том числе и контейнеров

ПОСЛЕДОВАТЕЛЬНЫЕ КОНТЕЙНЕРЫ
Последовательные контейнеры STL хранят коллекции объектов одного типа Т, обеспечивая их строгое линейное упорядочивание.
Вектор - динамический массив типа std::vector<T>, характеризуется произвольным доступом и автоматическим изменением размера при добавлении и удалении элементов
Дек(двусторонняя очередь, deque - double-ended queue) - аналог вектора типа std::deque<T> c возможностью быстрой вставки и удаления элементов в начале и конце контейнера
Список - контейнер типа std::list<T>, обеспечивающий константное время вставки и удаления в любой точке, но отличающийся линейным временем доступа.

Примечание: Последовательными контейнерами STL в большинстве случаев могут считаться массив T a[N] и класс std::string

УПОРЯДОЧЕННЫЕ АССОЦИАТИВНЫЕ КОНТЕЙНЕРЫ
Упорядоченные ассоциативные контейнеры STL представляют возможность быстрого доступа к объектам коллекции переменной длины, основанных на работе с ключами
Множество - контейнер типа std::set<T> c поддержкой уникальности ключей и быстрым доступом к ним. Мультимножество - аналогичный множеству контейнер типа std::multimap<T> c возможностью размещения в  нем ключей кратности 2 и выше.
Отображение - контейнер типа std::map<Key, T> с поддержкой уникальных ключей типа Key и быстрым доступом по ключам к значениям типа Т. Мультиотображение - аналогичным отображению контейнер типа std::multimap<Key, T> с возможностью размещенияя в нем пар значений с ключами кратности 2 и выше.

ВЕКТОРЫ: ОБЩИЕ СВЕДЕНИЯ
Вектор - последовательный контейнер
   * переменной длины
   * с произвольным доступом к элементам
   * с быстрой вставкой и удалением элементов в конце контейнера
   * с частичной гарантией сохранения корректности итераторов после вставки и удаления
Технически вектор STL реализован как шаблон с параметрами вида:
// 1-й параметр - тип данных, 2-й распределитель памяти
template<typename T, typename Allocator = std::allocator<T> >

ДЕКИ: ОБЩИЕ СВЕДЕНИЯ
Дек - последовательный контейнер
   * переменной длины
   * с произвольным доступом к элементам
   * с быстрой вставкой и удалением элементов в начале и конце контейнера
   * без гарантии сохранения корректности итераторов после вставки и удаления
Технически дек реализован как шаблон с параметрами вида:
template<typename T, typename Allocator = std::allocator<T> >
Предоставляемые встроенные типы и порядок конструкции аналогичны таковым для контейнера std::vector<T>

СПИСКИ: ОБЩИЕ СВЕДЕНИЯ
Список - последовательный контейнер
   * переменной длины
   * с двунаправленными итераторами для доступа к элементам
   * с быстрой вставкой и удалением элементов в любой позиции
   * со строгой гарантией сохранения корректности итераторов после вставки и удаления
Технически список реализован как шаблон с параметрами вида:
template<typename T, typename Allocator = std::allocator<T>>

Предоставляемые встроенные типы и порядок конструкции аналогичны таковым для контейнера std::vector<T>

МНОЖЕСТВА И МУЛЬТИМНОЖЕСТВА: ОБЩИЕ СВЕДЕНИЯ
Множества, мультимножества - упорядоченные ассоциативные контейнеры
   * переменной длины
   * с двунаправленными итераторами для доступа к элементам
   * с логарифмическим временем доступа
Технически множества и мультимножества STL реализованы как шаблоны с параметрами вида:
// 1-ый пар. - тип ключа, 2-й - функция сравнения
template<typename Key, typename Compare = std::less<Key>, typename Allocator = std::allocator<Key>>

ОТОБРАЖЕНИЯ И МУЛЬТИОТОБРАЖЕНИЯ: ОБЩИЕ СВЕДЕНИЯ
Отображения, мультиотображения - упорядоченныме ассоциативные контейнеры переменной длины:
   * моделирующие структуры данных типа "ассоциативный массив с (не)числовой индексацией"
   * с двунаправленными итераторами для доступа к элементам
   * с логарифмическим временем доступа
Технически отображения и мультиотображения STL реализованы как шаблоны с параметрами вида:
// 1-ый, 2 пар - тип ключа и связанных данных,
// 3-й - функция сравнения
template <typename Key, typename T, typename Compare=std::less<Key>, typename Allocator=std::allocator<std::pair<const Key, T>>>


ОБОБЩЕННЫЕ АЛГОРИТМЫ: ОБЗОР
Обобщенные алгоритмы STL предназначены для эффективной обработки обобщенных контейнеров и делятся на четыре основных группы:
Последовательные алгоритмы: немодифицирующие, модифицирующие
Алгоритмы упорядочивания
Алгоритмы на числах

ПОСЛЕДОВАТЕЛЬНЫЕ АЛГОРИТМЫ
Немодифицирующие последовательные алгоритмы - не изменяют содержимое контейнера-параметра и решают задачи поиска перебором, подсчета элементов и установления равенства двух контейнеров.
Например: std::find(), std::equal(), std::count()

Модифицирующие последовательные алгоритмы - изменют содержимое контейрена-параметра, решая задачи копирования, замены, удаления, размещения, перестановки значений и пр.
Например: std::copy(), std::random_shuffle(), std::replace()

АЛГОРИТМЫ УПОРЯДОЧИВАНИЯ. АЛГОРИТМЫ НА ЧИСЛАХ
Алгоритмы упорядочивания - все алгоритмы STL, работа которых опирается на наличие или установление отношения порядка на элементах. К данной категории относятся алгоритмы сортировки и слияния последовательностей, бинарного поиска, а также теоретико-множественные операции на упорядоченных структурах
Например: std::sort(), std::binary_search(), std::set_union()

Алгоритмы на числах - алгоритмы обобщенного накопления, вычисления нарастающего итога, попарных разностей и скалярных произведений.
Например: std::accumulate(), std::partial_sum(), std::inner_product()

КОПИРУЮЩИЕ, ПРЕДИКАТНЫЕ И АЛГОРИТМЫ, РАБОТАЮЩИЕ НА МЕСТЕ
Среди обобщенных алгоритмов STL выделяют:
   * работающие на месте - размещают результаты поверх исходных значений, которые при этом безвозвратно теряются.
   * копирующие - размещают результат в других контейнерах или не перекрывающей входные значения области того же контейнера.
   * принимающие функциональный параметр - допускают передачу на вход(обобщенной) функции с одним или двумя параметрами.

Наибольшее значение среди функций, принимаемых на вход обобщенными алгоритмами, имеют следующие:
   * обобщенная функция двух аргументов типа T, возвращающая значение типа T. Может наследоваться от std::binary_function<T, T, T>
   * обобщенная логическая функция(предикат) одного аргумента, может наследоваться от std::unary_function<T, bool>
   * обобщенная логическая функция(предикат) двух аргументов, может наследоваться от std::binary_function<T, T, bool>

ОТНОШЕНИЕ СРАВНЕНИЯ
Использумые в обобщенных алгоритмах STL отношения сравнения формально являются бинарным предикатом, к которым - для получения от алгоритмов предсказуемых результатов - предъявляется ряд требований. Так если отношение сравнения R определяется на множестве S, достаточно(но более, чем необходимо), чтобы:
   * для всех x,y,z из S имело бы утверждение: xRy ^ yRz => xRz
   * для всех x,y,z из S имелоб быть тоолько одно из следующих утверждений: xRy или yRx или x = y
   
Отвечающее указанным требования отношения сравнения являются строгим полным порядком и реализуется например:
   * операцией < над базовыми типами языка С++
   * операцией-функцией operator < () класса std::string
   * входящим в STL предикатным фунциональным объектом std::less<T>

Необходимым условием применимости бинарного предиката R как отношения сравнения в алгоритмах STL является допущение о том, что элементы x,y из S, для которых одновременно наверны утверждения xRy, yRx, x=y, тем не менее признаются эквивалентными(по отношению R - строгий слабый порядок).
В этом случае любые два элемента, взаимное расположение которых по отношению R не определено, объявляются эквивалентными.
Примечание: такая трактовка эквивалентности не предполагает никаких суждений относительно равенства элементов, устанавливаемого операцией сравнения ==.
   * Напривер сравнения строк без учета регистроа символов

ОБРАТНЫЕ ОТНОШЕНИЯ
При необходимости отношения C, обратное R на множестве S, такое, что xCy <=> yRx, может быть смоделировано средствами STL.
Так, при наличии operator<() для произвольного типа Т обратное отношение определяется реализованнмым в STL шаблоном обобщенной функции сравнения вида:
template<typename T>
inline bool operator > (const T& x, const T& y) {
   return y < x;
}
Для удобства использования данная функция инкапсулирована в предикатный функциональный объект std::greater<T>();
   
АЛГОРИТМЫ СОРТИРОВКИ
std::sort
   Нестабильная сортировка на месте(вариант quicksort) в среднем за O(NlogN)
   Наиб. время: O(N*N)
std::partitial_sort
   Нестабильная сортировка на месте(вариант heapsort; допускает получение отсортир. поддиапазона длины k)
   Наиб. время: O(NlogN) или O(NlogK)
std::stable_sort
   Стабильная сортировка на месте (вариант mergesort, адаптируется к ограничениям по памяти, оптимально - наличие памяти под N/2 элементов)
   Наиб. время: от O(NlogN) до O(N(logN)^2) (при отсутствии памяти)

ОПЕРАЦИИ НАД МНОЖЕСТВАМИ И ХИПАМИ: ОБЗОР
Реализуемые обобщенными алгоритмами STL операции над множествами имеют традиционное теоретико-множественное значение и выполняются над отсортированными диапазонами, находящимися в любых контейнерах STL
В дополнение к прочим STL вводит в рассмотрение такую структуру данных, как хип. Хип(max heap) - порядок организации данных в спроизвольным доступом к элементам в диапазоне итераторов [a; b), при котором:
   * значение, на которое указывает итератор а, является наибольшим в диапазоне и может быть удалено из хипа операцией извлечения(pop), а новое значение - добавлено в хип за время O(logN) операцией размещения (push)
   * результатоами опреации push и pop является корректные хипы.

