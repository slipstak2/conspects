ЛЯМБДА-ФУНКЦИИ И ЗАМЫКАНИЯ(С++11)
Лямбда-функция - третий(наряду с указателями на функции и классами-функторами) вариант реализации функциональных объектов в языке С++11, обязанный своим названием лямбда-исчислению - математической системе определения и применения функций, в которой аргументом одной функции(оператора) может быть другая функция(оператор)
Как правило, лямбда-функции являются анонимными и определяются в точке их применения
Возможность присваивать такие функции переменным позволяет именовать их лямбда-выражениями

Лямбда-функции(лямбда-выражения) могут использоваться всюда, где требуется передача вызываемому объекту функции соответствующего типа, в том числе - как фактические параметры обобщенных алгоритмов STL.
В лямбда-функции могут использоваться внешние по отношению к ней переменные, образующие замыкание этой функции.
Многие лямбда-функции весьма просты. Например функция:
[] (int x) { return x % m == 0; }
эквивалента функция вида:
bool foo(int x) { return x % m == 0; }

ОСНОВНЫЕ ПРАВИЛА ОФОРМЛЕНИЕ ЛЯМБДА-ФУНКЦИЙ(С++11)
При преобразовании функции языка С++ в лямбда-функцию необходимо учитывать, что имя функции заменяется в лямбда-функции квадратными скобками [], а возвращаемый тип лямбда-функции:
   * не определяется явно(слева)
   * при анализе лямбда-функции с телом вида
      return expr;
   * автоматически выводится компилятором как decltype(expr);
   * при отсуствии в теле однооператорной лямбда-функции оператора return автоматически принимается равным void;
   * в остальных случаях должен быть задан программистом при помощи "хвостового" способа записи:
      [](int x) -> int {
         int y = x; 
         return x - y;
      }
      
КЛЮЧЕВЫЕ ПРЕИМУЩЕСТВА ЛЯМБДА-ФУНКЦИЙ (С++11)
   * Близость к точке использования - анонимные лямбда-функции всегда определяются в месте их дальнейшего применения и являются единственным функциональным объектом, определяемым внутри вызова другой функции.
   * Краткость - в отличие от классов-функторов немногословны, а при наличии имени могут использоваться повторно.
   * Эффективность - как и классы-функторы, могут встраиваться компилятором в точку определения на уровне объектного кода.
   * Дополнительные возможности - работа с внешними переменными, входящими в замыкание лямбда-функции.
   
Именованные и анонимные лямбда-функции: пример (С++11)
// для анонимных лямбда-функций:
std::vector<int> v1;
std::vector<int> v2;
std::transform(v1.begin(), v1.end(), v2.begin(), [](int x) {return ++x;});

// для именованных лямбда-функций:
// тип lt10 зависит от реализации компилятора
auto lt10 = [](int x) { return x < 10; }
int cnt = std::count_if(v1.begin(), v1.end(), lt10);
bool b = lt10(300);     // b == false;

Внешние переменные и замыкание лямбда-функций(С++11)
Внешние по отношению к лябмбда-функции автоматические переменные, определенные в одной с ней области видимости, могут захватываться лямбда-функцией и входить в ее замыкание. При этом в отношении доступа к переменным действуют следующие соглашения:
   * [z]  - доступ по значению к одной переменной (z);
   * [&z] - доступ по ссылке к одной переменной(z);
   * [=] - доступ по значению ко всем автоматическим переменным
   * [&] - доступ по ссылке ко всем автоматическим переменным
   * [&, z], [=, &z], [z, &zz] - смешанный вариант доступа
   
ВНЕШНИЕ ПЕРЕМЕННЫЕ И ЗАМЫКАНИЕ ЛЯМБДА-ФУНКЦИЙ: ПРИМЕР С++(11)
int countN;
std::vector<double> d; // ... 
countN = std::count_if(vd.begin(), vd.end(),
                      [](double x) {return x >=N; });

// эквивалентно
int countN = 0;
std::vector<double> vd; // ...
std::for_each(vd.begin(), vd.end(),
              [&countN](double x) { countN += x >= N; });
              
БИБЛИОТЕКА BOOST: ОБЩИЕ СВЕДЕНИЯ? 
Boost - набор из более 80 автономных библиотек на языке С++, задуманный в 1998 г. Б.Давесом(Beman Dawes), Д. Абрахамсом (David Abrahams) и др.
Основными целями разработки Boost выступают:
   * решение задач, выходящих за пределы возможностей стандартной библиотеки C++ в целом и STL - в частности
   * тестирование новых библиотек-кандидатов на включение в принимаемые и перспективные стандарты языка С++.
Преимущества и недостатки Boost связаны с активным использованием в Boost шаблонов и техник обобщенного программирования, что открывает перед программистами новые возможности, но требует немалой предварительной подготовки.

СОСТАВ И НАЗНАЧЕНИЕ BOOST
Библиотеки BOOST:
   Обобщенное программирование
   Алгоритмы
   Контейнеры
   Структуры данных
   Функциональные объекты
   Параллельное программирование
   Синтаксический анализ
   Мета-программирование на базе препроцессора и шаблонов
   Работа с памятью
   Математические задачи
   Ввод-вывод
   Обработка изображений
BOOST: примеры
   Продемонстрируем работу Boost на следующих примерах:
      * внедрение в исходный код проверок времени компиляции - позволяет не допускать компиляции логически или семантически неверного кода
      * применение вариантных контейнеров и произвольных типов - открывает возможность создания обобщенных и универсальных структур хранения данных
      * применение циклических контейнеров - дает возможность поддержки программной кэш-памяти и эффективных FIFO/LIFO-структур фиксированного размера
      
ПРИМЕР 1. ПРОВЕРКИ ВРЕМЕНИ КОМПИЛЯЦИИ: ОБЩИЕ СВЕДЕНИЯ
Цель. Проверки времени компиляции(static assertions) призваны предупредить случаи некорректного использования библиотек, ошибки при передаче параметров шаблонам и пр.
Библиотека.
#include <boost/static_assert.hpp>
Состав. Проверки времени компиляции представляют собой два МАКРООПРЕДЕЛЕНИЯ(x - целочисленная константа, msg - строка)
BOOST_STATIC_ASSERT(x)
BOOST_STATIC_ASSERT_MSG(x, msg)
являются статическим аналогом стандартного макроопределения assert и пригодны для применения на уровне пространства имен, функции или класса

ПРИМЕР1. ПРОВЕРКА ВРЕМЕНИ КОМПИЛЯЦИИ: РЕАЛИЗАЦИЯ
Реализация. На уровне программной реализации в Boost макроопределения BOOST_STATIC_ASSERT* задействует общий и полностью специализированный шаблон структуры вида:
namespace boost {
   template<bool>
   struct STATIC_ASSERTION_FAILURE;
   
   template<>
   struct STATIC_ASSERTION_FAILURE<true> {}
}

ПРИМЕР1: Проверки времени компиляции: использование
#include <climits>
#include <limits>
#include <boost/static_assert.hpp>

namespace my_conditions {
   // проверка: длина int - не менее 32 бит
   BOOST_STATIC_ASSERT(std::numeric_limits<int>::digits >= 32);
}

ПРИМЕР 2. ВАРИАНТНЫЙ КОНТЕЙНЕР: ОБЩИЕ СВЕДЕНИЯ
Цель. Предоставление безопасного обобщенного контейнера-объединения различимых типов со следующими возможностями:
   * поддержка семантики значений, в том числе стандартных правил разрешения типов при перегрузке.
   * безопасное посещение значений с проверками времени компиляции посредством boost::apply_visitor();
   * явное извлечение значений с проверками времени выполнения посредством boost::get()
   * поддержка любых типов данных (POD и не-POD), отвечающих минимальным требованиям(см. далее).
Библиотека.
#include<boost/variant.hpp>
Состав. Шаблон класса boost::variant с переменным числом параметров, сопутствующие классы и макропоределения

ПРИМЕР 2. Вариантный контейнер: требования к типам-параметрам
Обязательные характеристики типов параметров шаблона boost::variant^
   * наличие конструктора копирования
   * соблюдение безопасной по исключениям гарантии throw() для деструктора.
   * полнота определения к точке инстанцирования шаблона boost::variant
Желательные характеристики типов параметров шаблона boost::variant
   * возможность присваивания(отсутствует для константных объектов и ссылок!)
   * наличие конструктора по умолчанию
   * возможность сравнения по отношениям "равно" и "меньше"
   * поддержка работы с выходным потоком std::ostream

ПРИМЕР 2. ВАРИАНТНЫЙ КОНТЕЙНЕР: ОПРЕДЕЛНИЕ И ОБХОД ЭЛЕМЕНТОВ
// создание использование экземпляра
boost::variant<int, std::string> u("hello world");
std::cout << u << std::endl;     // выдача: hello world

// для безопасного  обхода элементов контейнера-объединения
// может использоваться объект класса-посетителя
boost::apply_visitor(
   times_two_visitor(),    // объект-посетитель
   v                       // контейнер
);

class times_two_visitor: public boost::static_visitor<> {
   public:
      void operator() (int& i) const {
         i *= 2;
      }
      
      void operator() (std::string& str) const {
         str += str;
      }
}

// реализация класса-посетителя может быть обобщенной
class times_two_generic: public boost::static_visitor<> {
   public:  
      template <typename T>
      void operator() (T& operand) const {
         operand += operand;
      }
}

ПРИМЕР 3. ПРОИЗВОЛЬНЫЙ ТИП: ОБЩИЕ СВЕДЕНИЯ
Цель. Предоставление безопасного обобщенного класса-хранилица единичных значений любых различимых типов, в отношении которых не предполагается выполнение произвольных преобразований. Основные возможности:
   * копирование значений без ограничений по типам данных;
   * безопасное проверяемое извлечение значения в соответствии с его типом.
Библиотека.
#include <boost/any.hpp>
Состав. Шаблон класса boost::any, сопутствующие классы, в том числе производный от std::bad_cast классы boost::bad_any_cast, и другие программыне элементы.

ПРИМЕР 3. ПРОИЗВОЛЬНЫЙ ТИП: класс boost::any
class any {
   public:
      // конструкторы, присваивания, деструкторы
      any();
      any(const any&);
      template<typename ValueType> any(const ValueType&);
      any& operator = (const any&);
      template<typename ValueType> any& operator = (const ValueType&);
      ~any();
      any& swap(any&);                    // модификатор
      bool empty() const;                 // запрос #1
      const std::type_info& type() const  // запрос #2
};

ПРИМЕР 3. ПРОИЗВОЛЬНЫЙ ТИП: РАБОТА СО СТАНДАРТНЫМИ СПИСКАМИ
// двусвязный список значений произвольных типов
// может формироваться так:
typedef std::list<boost::any> many;

void append_string(many& values, const std::string& value) {
   values.push_back(value);
}
void append_any(many& values, const boost::any& value) {
   values.push_back(value);
}
void append_nothing(many& values) {
   values.push_back(boost::any());
}

ПРИМЕР 3. ПРОИЗВОЛЬНЫЙ ТИП: ПРОВЕРКА ТИПОВ ЗНАЧЕНИЙ
bool is_int(const boost::any& operand) {
   return operand.type() == typeid(id);
}
bool is_char_ptr(const boost::any& operand) {
   try {
      boost::any_cast<const char*>(operand);
      return true;
   }
   catch(const boost::bad_any_cast&) {
      return false;
   }
}

ПРИМЕР 4. ЦИКЛИЧЕСКИЙ БУФЕР: ОБЩИЕ СВЕДЕНИЯ
Цель. Снабдить программиста STL-совместимым контейнером типа "кольцо" или "циклическим буфером", который служит для приема поступающих данных, поддерживает перезапись элементов при заполнении, а также:
   * реализует хранилище фиксированного размера
   * предоставляет итератор произвольного доступа
   * константное время вставки и удаления в начале и конце буфера
   
Библиотека.
#include <boost/circular_buffer.hpp>
Состав. Шаблон класса boost::circular_buffer, адаптер boost::circular_buffer_space_optimized и другие программные элементы.

ПРИМЕР 4: ЦИКЛИЧЕСКИЙ БУФЕР: ТЕХНИКА ПРИМЕНЕНИЯ
Использование. Циклический буфер и его адаптированный вариант на физическом уровне работают с непрерывном участком памяти в силу чего не допускают неявных или непредсказуемых запросов на выделение памяти.
Возможные применения буферов включают, в том числе:
   * хранение последних полученных(обработанных, использованных) значений.
   * создание программной кэш-памяти
   * реализацию ограниченных буферов(bounded buffer)
   * реализацию FIFO/LIFO-контейнеров фиксированного размера.

ПРИМЕР 4. ЦИКЛИЧЕСКИЙ БУФЕР: ПОРЯДОК ИСПОЛЬЗОВАНИЯ
boost:circular_buffer<int> cb(3);
cb.push_back(1);
cb.push_back(2);
cb.puhs_back(3);
// буфер полон, дальнейшая запись приводит к перезаписи элементов
cb.push_back(4);  // значение 4 вытесняет 1
cb.push_back(5);  // значение 5 вытесняет 2

// буфер содержит значения 3, 4, 5
cb.pop_back();    // 5 выталкивается из посл. позиции
cb.pop_front();   // 3 выталкивается из нач. позиции

BOOST: ЧТО ЕЩЕ?
Boost Interval Container Library(ICL) - библиотека интервальных контейнеров с поддержкой множеств и отображений интервалов:
// работа с интервальным множеством
boost::interval_set<int> my_set;
my_set.insert(42);
bool has_answer = boost::contains(my_set, 42);

Boost.Tribool - поддержка тернарной логики "да, нет, возможно"
boost::tribool(true);
b = false;
b = boost::indetermate;

Boost.Units - библиотека поддержки анализа размерностей(единиц измерения) операндов вычислительных операций. Задача анализа рассматривается как обобщенная задача метапрограммирования времени компиляции:
quantity<force>  F(2.0 * newton); // сила
quantity<length> dx(2.0 * meter); // расстояние
quantity<energy> E(work(F, dx));  // энергия

МАТЕМАТИЧЕСКИЕ БИБЛИОТЕКИ
Математическими библиотеками Boost, в частности, выступают:
   * Geometry - решение геометрических задач(например, вычисление расстояния между точками в сферической системе координат)
   * Math Toolkit - работа со статистическими распределениями, специальными математическими функциями(эллиптическими интегралами, гиперборлическими функциями, полиномами Эрмита и пр.), бесконечными рядами и др.
   * Quaternions - поддержка алгебры кватернионов;
   * Ratio - поддержка рациональных дробей(cр std::ratio в С++)
   * Meta State Machine - работа с автоматными структурами
   * и др.

СИСТЕМА ТИПОВ ЯЗЫКА С++: КОНЦЕПТЫ(CONCEPTS TS)
Исторически С++ всегда являлся типизированным языком со слабой статической типизацией, при этом абстрактные представления об универсальных(повторяющихся) свойствах типов как программных категорий в нем долгое время отсутствовали.
Согласно сегодняшним представлениям, концепт(concept) - это именованное множество требований к типу в языке С++.
Формальное определение концептов средствами С++ будет закреплено технической специфицикацией ISO/IES PDTS 19217 Information Technology - Programming Languaes, Their Environments ans Systems Software - C++ Extensions for Concepts(май 2015 - в разработке).
Рассматриваемые далее концепты(именованные требования к типам) используются в тексте стандарта языка С+ и описывают непроверяемые(сейчас) ожидания стандартной библиотеки в отношении параметров функций и аргументов шаблонов

ИМЕНОВАННЫЕ ТРЕБОВАНИЯ СТАНДАРТНОЙ БИБЛИОТЕКИ С++
Широкое применение типовых сочетаний требований к характеристикам стандартных и пользовательских типов привело к появлению понятия именованных требований(стандартной библиотеки)
Среди них базовыми являются:
   * DefaultConstructible / Destructible - объект типа может быть создать конструктором по умолчанию / тип имеет деструктор.
   * CopyAssignable / CopyConstructible - объект типа может быть изменен присваиванием / создан из леводопустимого значения.
   * MoveAssignable / MoveConstructible(оба - С++11) - объект типа может быть изменен / создан переносом из праводопустимого значения

Другими именованными требованиями являются:
   * требования к размещению: TriviallyCopyable, TrivialTYpe, StandartLayoutType(Все - С++11), PODType;
   * требования уровня библиотеки: Swappable, ValueSwappable, NullablePointer, Hash(все - С++11), EqualityComparable, LessThanComparable, Allocator, FunctionObject, Callable, Predicate, BinaryPredicate, Compare;
   * требования к контейнерам: Container - тип является структурой данных с доступом к элементам по итераторам; ReversibleContainer, AllocatorAwareContainer(C++11), SequenceContainer, ContiguousContainer(C++17), AssociativeContainer, UnorderedAssociativeContainer(C++11)
   * требования к элементам контейнеров, функциям потокового B/B, генераторам случайных чисел(С++11), асинхронным функциям(С++11) и др.

СТАНДАРТНЫЕ ФУНКЦИИ ПРОВЕРКИ СООТВЕТСТВИЯ ТРЕБОВАНИЯМ
В стандартную библиотеку языка С++11 введены шаблоны структур, устанавливающие соответствие типов-параметров предъявляемым требованиям.
Например, для требования CopyConstructible:
template<class T> struct is_copy_constructible;
template<class T> struct is_trivially_copy_constructible;
template<class T> struct is_nothrow_copy_constructible;

Для интроспекции типов-параметров служит открытый статический константный атрибут шаблона структуры value.

СТАНДАРТНЫЕ ФУНКЦИИ ПРОВЕРКИ СООТВЕТСТВИЯ ТРЕБОВАНИЯМ: ПРИМЕР
struct foo {
   string _s;        // атрибут с нетривиальным
                     // string::string(const string&)
};

struct bar {
   int _n;                       // тривиальный конструктор,
   bar(const bar&) = default;    // безопасный по исключениям
};

// is_copy_constructible<foo>::value == true
// is_trivially_copy_constructible<foo>::value == false
// is_trivially_copy_constructible<bar>::value == true
// is_nothrow_copy_constructible<bar>::value == true

ТРЕБОВАНИЯ COPYCONSTRUCTIBLE
Базовое именованное трабование к типу - тип, отвечающих требованию CopyConstructible, реализует одну или несколько следующих функций:
   Type::Type(Type& other);
   Type::Type(const Type& other);
   Type::Type(volatile Type& other);
   Type::Type(const volatile Type& other);
и гарантирует работоспособность следующих выражений, вычисления которых должны давать правильный, с языковое точки зрения результат:
Type a = v;
Type(v);

ТРЕБОВАНИЯ TrivialType, TriviallyCopyable
Требования к размещению объектов - тип T, удовлетворяющий требованию TiviallyCopyable, отвечает следующим критериям:
   * обладает тривиальными конструкторами копирвоания и переноса
   * обладает тривиальными операциями присваивания путем копирования и переноса
   * обладает тривиальным деструктором
   * не имеет виртуальных методов и(или) виртуальных базовых классов;
   * все(нестатические) члены данных и базовые классы T удовлетворяют требованию TriviallyCopyable
Тривиально копируемыми являются скалярные типы и массивы тревиально копируемых объектов, а также квалифицированные const (но не volatile!) версии соответсвующих типов.
Тривиально копируемый тип с тривиальным конструктором по умолчанию является тривиальным типом(требование TrivialType)

ТРЕБОВАНИЕ PodType
Требования к размещению объектов - тип T, удовлетворяющий требованию PODType является скалярным типом либо классом, являющимся тривиальным типом(TrivialType) и типом со стандартным размещением(StandartLayoutType), не имеющим нестатических членов данных, которые не удовлетворяют требованию PODType, либо массивом таких классов или скалярных типов.
Соответствие типа требованию PODType указывает на то, что:
   * тип совместим с типами, используемыми в языке С.
   * объекты типа могут обрабатываться функциями из библиотеки языка С, размещаться в памяти при помощи std::malloc(), копироваться при помощи std::memmove() и т.д.
   * объекты типа могут передаваться в библиотеки языка С в двоичной(машинной) форме.

ТРЕБОВАНИЕ Container
Объекты типа, отвечающего требования Container, содержат другие объекты и отвечают за управление памятью, выделенной для хранения содержащихся в них объектов.
Пусть C - тип Container, T - тип элемента. Тогда:
   * тип С реализует поддержку встроенных типов value_type, reference, const_reference, iterator, const_iterator, difference_type, size_type;
   * тип С реализует операции создания пустого и непустого контейнера, присваивание, сравнения, возврата итераторов на начало(конец) и пр.
   * тип C отвечает требованиям DefaultConstructible, CopyConstructible, EqualiltyComparable, Swappable
   * тип T отвечает требованиям CopyInsertable, EqualityComparable, Destructible.


ТРЕБОВАНИЯ К ТИПАМ И ХАРАКТЕРИСТИКИ ТИПОВ
Именованные требования к типам не следует смешивать с рассмотренными ранее характеристиками типов (type traits), посредством которых для соответствующих нужд выделяются простые и составные категории типов(type categories):
   * порядковые типы(проверочный шаблон - std::is_integral<>, C++11)
   * вещественные типы(std::is_floating_point<>, C++11)
   * массивы, перечисления, классы, объединения(все С++11)
   * арифметические типы(порядковые или вещественные; std::is_arithmetic<>, C++11)
   * фундаментальные типы(арифметические, void или std::nullptr_t; std::is_fundamental<>, C++11);
   * скалярные типы(арифметические, указатели, указатели на члены классов или std::nullptr_t, std::is_scalar<>, C++11)
   * объекты(скаляры, массивы, классы или объединения; std::is_object<>, C++11) и пр.
