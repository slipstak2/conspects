ЛЯМБДА-ФУНКЦИИ И ЗАМЫКАНИЯ(С++11)
Лямбда-функция - третий(наряду с указателями на функции и классами-функторами) вариант реализации функциональных объектов в языке С++11, обязанный своим названием лямбда-исчислению - математической системе определения и применения функций, в которой аргументом одной функции(оператора) может быть другая функция(оператор)
Как правило, лямбда-функции являются анонимными и определяются в точке их применения
Возможность присваивать такие функции переменным позволяет именовать их лямбда-выражениями

Лямбда-функции(лямбда-выражения) могут использоваться всюда, где требуется передача вызываемому объекту функции соответствующего типа, в том числе - как фактические параметры обобщенных алгоритмов STL.
В лямбда-функции могут использоваться внешние по отношению к ней переменные, образующие замыкание этой функции.
Многие лямбда-функции весьма просты. Например функция:
[] (int x) { return x % m == 0; }
эквивалента функция вида:
bool foo(int x) { return x % m == 0; }

ОСНОВНЫЕ ПРАВИЛА ОФОРМЛЕНИЕ ЛЯМБДА-ФУНКЦИЙ(С++11)
При преобразовании функции языка С++ в лямбда-функцию необходимо учитывать, что имя функции заменяется в лямбда-функции квадратными скобками [], а возвращаемый тип лямбда-функции:
   * не определяется явно(слева)
   * при анализе лямбда-функции с телом вида
      return expr;
   * автоматически выводится компилятором как decltype(expr);
   * при отсуствии в теле однооператорной лямбда-функции оператора return автоматически принимается равным void;
   * в остальных случаях должен быть задан программистом при помощи "хвостового" способа записи:
      [](int x) -> int {
         int y = x; 
         return x - y;
      }
      
КЛЮЧЕВЫЕ ПРЕИМУЩЕСТВА ЛЯМБДА-ФУНКЦИЙ (С++11)
   * Близость к точке использования - анонимные лямбда-функции всегда определяются в месте их дальнейшего применения и являются единственным функциональным объектом, определяемым внутри вызова другой функции.
   * Краткость - в отличие от классов-функторов немногословны, а при наличии имени могут использоваться повторно.
   * Эффективность - как и классы-функторы, могут встраиваться компилятором в точку определения на уровне объектного кода.
   * Дополнительные возможности - работа с внешними переменными, входящими в замыкание лямбда-функции.
   
Именованные и анонимные лямбда-функции: пример (С++11)
// для анонимных лямбда-функций:
std::vector<int> v1;
std::vector<int> v2;
std::transform(v1.begin(), v1.end(), v2.begin(), [](int x) {return ++x;});

// для именованных лямбда-функций:
// тип lt10 зависит от реализации компилятора
auto lt10 = [](int x) { return x < 10; }
int cnt = std::count_if(v1.begin(), v1.end(), lt10);
bool b = lt10(300);     // b == false;

Внешние переменные и замыкание лямбда-функций(С++11)
Внешние по отношению к лябмбда-функции автоматические переменные, определенные в одной с ней области видимости, могут захватываться лямбда-функцией и входить в ее замыкание. При этом в отношении доступа к переменным действуют следующие соглашения:
   * [z]  - доступ по значению к одной переменной (z);
   * [&z] - доступ по ссылке к одной переменной(z);
   * [=] - доступ по значению ко всем автоматическим переменным
   * [&] - доступ по ссылке ко всем автоматическим переменным
   * [&, z], [=, &z], [z, &zz] - смешанный вариант доступа
   
ВНЕШНИЕ ПЕРЕМЕННЫЕ И ЗАМЫКАНИЕ ЛЯМБДА-ФУНКЦИЙ: ПРИМЕР С++(11)
int countN;
std::vector<double> d; // ... 
countN = std::count_if(vd.begin(), vd.end(),
                      [](double x) {return x >=N; });

// эквивалентно
int countN = 0;
std::vector<double> vd; // ...
std::for_each(vd.begin(), vd.end(),
              [&countN](double x) { countN += x >= N; });