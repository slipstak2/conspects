ШАБЛОНЫ КЛАССОВ
Шаблоны классов - элемент языка, позволяющий, среди прочего, использовать типы и значения как параметры, используемые для автоматического создания(конкретизации) классов по обобщеному описанию(шаблону).
Использование шаблонов классов - шаг на пути к парадигме обобщенного программирования.
Различают описания и определения шаблонов классов. В отличии от "обычного" класса описания и определения шаблона содержат списки параметров шбалона, среди которых выделяются параметры-типы, параметры-значения и параметры-шаблоны.
Параметры-типы шаблона класса представляют некоторый тип данных, параметры-значения - некоторые константное(вычисляемое при компиляции) выражение

ПАРАМЕТРЫ-ЗНАЧЕНИЯ И ПАРАМЕТРЫ-ШАБЛОНЫ
Параметры-значения могут иметь необязательный идентификатор, необязательное значение по умолчани и должны иметь тип, являющийся логическим, символьным или ценым, перечислением, указателем или леводопустимыой ссылкой на функцию или объект, указателем на член класса или равный std::nullptr_t.
   * Типы-массивы T[] сводятся к указателям T*, а типы-функции - к указателям на функции, соответственно.
Параметры-шаблоны могут иметь необязательный идентификатор, наобязательное значение по умолчанию и специфицируются при помощи ключевых слов:
   * class - в диалектах C++11, C++14;
   * class или typename - в диалекте C++17


ПАРАМЕТРЫ-ТИПЫ И ПАРАМЕТРЫ-ЗНАЧЕНИЯ: ПРИМЕР
template <class T, class U, int size>
// эквивалентно:
// template <typename T, typename U, int size>
class Sample {
   public:
      Sample(): _size(size) {}
   private:
      T     _prm_1;
      U*    _prm_2;
      int   _size;
};


template <class T>
class Array {
   // ...
};

template <class Key, class Value,
          template<typename> class Container = Array>
class Map {
   public:
      Container<Key> key;
      Container<Value> value;
};

КОНКРЕТИЗАЦИЯ ШАБЛОНОВ:
АРГУМЕНТЫ-ЗНАЧЕНИЯ(С++03, С++1y)

Категория параметра        Ограничения на аргумент
-------------------------------------------------------
Арифметический тип         Константное выражение типы, соответствующего типу параметра 
                           шаблона(возможно неявные преобразования)

Указатель на объект        Адрес объекта со статической продолжительностью хранения и внешним
                           или внутренним связыванием или константное выражение, сводимое к соответствующему
                           пустому указателю или значение std::nullptr_t

Указтель на функцию        Адрес функции, обладающий связыванием, или константное выражение, сводимое
                           к соответствующему пустому указателю или значению std::nullptr_t

Леводопустимая ссылка      Не является временным, безымянным объектом или именованным объектом хранения без связывания

Указатель на член          Указатель на член класса вида &Class::Member или константное  адрес
класса                     выражение, вычисляемое в "пустой"


КОНКРЕТИЗАЦИЯ ШАБЛОНОВ: АРГУМЕНТЫ-ЗНАЧЕНИЯ(С++17)
Параметры-значения шаблонов могут конкретизироваться с использованием аргументов, являющихся произвольными приведенными константными выражениями, то есть выражениями, неявно приведенными к чистым праводопустимым выражениям(pure right-hand value, prvalue), в которых приведенное выражение является базовым константным выражением, а цепь неявных преобразования содержит только:
   * пользовательские преобразование с использованием constexpr;
   * преобразование леводопустимых значений в праводопустимые;
   * повышения и не сужающие преобразования целых или символьных типов;
   * преобразования массивов и функций в указатели(в C++17)
   * преобразование квалификаторов(в С++17)
   * преобразования пустых указателей с использованием std::nullptr_t (С++17)


template<const int *pci> struct Alpha {};
int arr[10];      // преобразование массива к указателю
Alpha<arr> alpha; // преобразование квалификаторов

struct Beta {}
template <const Beta &beta> struct Gamma {};

Beta beta;              // преобразования отсутствуют
Gamma<beta> gamma;      // избыточный квалификатор ингорир.

template<int (&pa) [42]> struct Delta {};
int container[42];      // преобразования отсутствуют
Delta<container> delta;

// примеры запрещенных к использованию аргументов-значений
template<class T, const char *str> class Phi {};
Phi<int, "ERROR"> phi;  // строковые литералы (НЕДОПУСТИМО)

template<int *p> class Chi {}
int a[42];
struct Psi {int ns, static int s; } psi;

Chi<&a[10]>    chi1;    // адреса элементов массива (НЕДОПУСТИМО)
Chi<&psi.ns>   chi2;    // адреса нестатических подобъектов (НЕДОПУСТИМО)
Chi<&psi.s>    chi3;    // ДОПУСТИМО
Chi<&Psi::s>   chi4;    // ДОПУСТИМО

template <const int& cri> struct Omega {};
Omega<1>    omega;      // временные объекты (НЕДОПУСТИМО)

ДРУЖЕСТВЕННЫЕ ОБЪЕКТЫ В ШАБЛОНАХ КЛАССОВ
Дружественными по отношению к шаблонам классов могут быть:
   * дружественная функция или дружественный класс(не шаблон)
   * связанный шаблон дружественной функции, взаимно однозначно соответствующий шаблону класса(с общим для обоих шаблонов списком параметров)
   * связанный шаблон дружесвтенного класса, взаимно однозначно соответствующий шаблону класса(с общим для обоих шаблонов списком параметров)
   * несвязанный шаблон дружественной функции, соответствующий всем возможным конкретизациям шаблона класса(с раздельными списками параметров)
   * несвязанный шаблон дружественного класса, соответствующий всем возможным конкретизациям шаблон класса(с раздельыми списками параметров).

СТАТИЧЕСКИЕ ЧЛЕНЫ ШАБЛОНОВ КЛАССА
Шаблоны классов могут содержать статические члены данных, собственный набор которых имеет каждый конкретизированный согласно шаблону класс

template<class T, class U, int size>
class Sample {
   private:
      static Sample *_head;
};

СПЕЦИАЛИЗАЦИЯ ШАБЛОНОВ КЛАССОВ. СПЕЦИАЛИЗАЦИЯ ЧЛЕНА КЛАССА
Шаблоны классов в С++ допускают частичную(полную) специализацию, при которой отдельные(все) параметры шаблона заменяются конкретными именами типов или значениями константных выражений.

// специализация члена класса
template<>
void Sample<int, double, 10>::foo() { };

template<class T, class U, int size>
Sample<T, U, size> *Sample<T, U, size>::_head = nullptr;

ПОЛНАЯ И ЧАСТИЧНАЯ СПЕЦИАЛИЗАЦИЯ КЛАССА: ПРИМЕР
// полная специализация класса
template<> class Sample<int, double, 100> {
   public:
      Sample<int, double, 100>();
      ~Sample<int, double, 100> ();
      void foo(); // ...
}

//частичная специализация класса
template <class T, class U> class Sample<T, U, 100> {
   public:
      Sample();
      ~Sample(); // ...
}

РЕКУРСИВНОЕ ОПРЕДЕЛЕНИЕ ШАБЛОНОВ КАК ПРИМЕР МЕТАПРОГРАММИРОВАНИЯ

template <unsigned long N>
struct binary {
   static unsigned const value = binary<N / 10>::value << 1 | N % 10;
};

template<> struct binary<0> {
   static unsigned const value = 0;
}

unsigned const one   = binary<1>::value;
unsigned const three = binary<11>::value;
unsigned const five  = binary<101>::value;


ИДИОМА SFINAE
Идиома SFINAE(Substitution Failure Is Not An Error - "неудача при подстановке не есть ошибка") является одной из идиом обобщенного программирования и озночает ситуацию, при которой невозможность подстановки параметров шаблона не влечет аварийного завершения компиляции.
Ситуация, соответствующая идиоме SFINAE, возникает при разрешении перегруженных вызовов, в которых среди множества функций-кандидатов найдется хотя бы одна, полученная в результате конкретизации шаблона.
В соответствии с логикой идиомы SFINAE, неудача при подстановке параметров в соответствующий шаблон ведет лишь к удалению данного шаблона из множества кандидатов и не имеет катастрофических последствий для компиляции

ИДИОМА SFINAE И ИНТРОСПЕКЦИЯ ВРЕМЕНИ КОМПИЛЯЦИИ: ПРИМЕР
template<typename T>
struct has_typedef_foobar {
   typedef char yes[1];    // sizeof(yes) == 1;
   typedef char no [2];    // sizeof(no)  == 2;
   
   template<typename C>
   static yes& test(typename C::foobar*);
   template <typename>
   static no& test(...);
   
   static const bool value = sizeof(test<T>(0)) == sizeof(yes);
};

struct foo {typedef float foobar; }
// has_typedef_foobar<int>::value == false
// has_typedef_foobar<foo>::value == true


ИНТРОСПЕКЦИЯ ВРЕМЕНИ КОМПИЛЯЦИИ В БИБЛИОТЕКЕ BOOST::TYPE_TRAITS
Цель. Через набор узкоспециализированных, имеющих единый дизайн вспомогательных классов упростить работу с атомарными характеристиками типов(type traits) в системе типов языка С++
Библиотека.
   #include <boost/type_traits.hpp>
Реализация. Библиотека характеристик типов содержит значительное количество внутренне весьма однородных классов(структур), многие из которых открыто наследуют типам true_type или false_type.

ХАРАКТЕРИСТИКИ ТИПОВ: СТРУКТУРЫ IS_VOID, IS_POINTER
// тип T является пустым типом?
template <typename T>
struct is_void : public false_type {}

template<>
struct is_void<void> : public true_type {};

// тип T является указателем?
template <typename T>
struct is_pointer: public false_type {};

template<typename T>
struct is_pointer<T*> : public true_type {}

ХАРАКТЕРИСТИКИ ТИПОВ: СТРУКТУРЫ TRUE_TYPE И FALSE_TYPE
template<class T, T val>
struct integral_constant {
   typedef integral_constant<T, val> type;
   typedef T      value_type;
   static const T  value = val;
};

typedef integral_constant<bool, true> true_type;
typedef integral_constant<bool, false> false_type;


ХАРАКТЕРИСТИКИ ТИПОВ: ИЕРАРХИИ КЛАССОВ
Проилюстрированный подход подволяет строить параллельные иерархии классов, обладающих (потомки true_type) и не обладающих(потомки false_type) искомыми свойствами. Принадлежность к соответствующей иерархии является различительным признаком.

ХАРАКТЕРИСТИКИ ТИПОВ: СТРУКТУРА REMOVE_EXTENT
Установить тип элемента массива позволяет структура remove_extent.

template<typename T>
struct remove_extent {
   typedef T type
};

template<typename T, std::size_t N>
struct remove_extent<T[N]> {
   typedef T type;
}

ХАРАКТЕРИСТИКИ ТИПОВ: ОПТИМИЗАЦИЯ ФУНКЦИЙ
Имея эффективную реализацию функции для типов с конкретными характеристиками, нетрудно должным образом специализировать ее шаблон. Например для std::copy имеем:

// общий случай
template<typename I1, typename I2, bool b>
I2 copy_imp(I1 first , I1 last, I2 out, const boost::integral_contant<bool, b>&) {
   while (first != last) {
      *out  = *first;
      ++out; ++first;
   }
   return out;
}

// оптимизированная реализация
template<typename T>
T* copy_imp(const T* first, const T* last, T* out, const boost::true_type&) {
   std::memmove(out, first, (last - first) * sizeof(T));
   return out + (last - first);
}

// общий случай
template<typename I1, typename I2>
inline I2 copy(I1 first, I1 last, I2 out) {
   typedef typename std::iterator_traits<I1>::value_type value_type;
   return copy_imp(first, last, out, boost::has_trivial_assign<value_type>());
}

ХАРАКТЕРИСТИКИ ТИПОВ: ИСКЛЮЧЕНИЕ ДЕСТРУКТОРОВ
Стольк же нетрудно избежать накладных расходов на вызов деструкторов в случаях, когда это допускат структура соответсвуюих классов

// вызов T::~T() обязателен
template<class T>
void do_destroy_array(T* first, T* last, const bools::false_type &) {
   while (first != last) {
      first->~T();
      ++first;
   }
}

// вызов T::~T() факультативен
template<class T>
inline void do_destroy_array(T* first, T* last, const boost::true_type &) {}

// вызывающая функция
template<class T>
inline void destroy_array(T* p1, T* p2) {
   do_destroy_array(p1, p2, boost::has_trivial_destructor<T>());
}

ПОНЯТИЕ ИСКЛЮЧИТЕЛЬНОЙ СИТУАЦИИ
Естественый порядок функционирования программ нарушают возникающие нештатные ситуации, в большинстве случаев связанные с ошибками времени выполнения(иногда - с необходимостью внезапно переключить контекст приложения).
В языке С++ такие нештатные ситуации называются исключительными(иначе говоря - исключениями). Например:
   * нехватка оперативной памяти
   * попытка доступа к элементу коллекции по некорректному индексу
   * попытка недопустимого преобразования динамических типов и пр.
Архитектурной особенностью механизма обработки исключительных ситуаций в языке С++ является принципиальная незавивисимость(несвязность) фрагментов программы, где исключение возбуждается и одно оно обрабатывается. Обработка исключительных ситуаций носит невозвратный характер.

ОБЪЕКТЫ-ИСКЛЮЧЕНИЯ. ОПЕРАТОР THROW
Носителями информации об аномальной ситации(исключении) в С++ являются объекты заранее выбранных на эту роль типов (пользовательских или - Sic! - базовых, например, char*). Такие объекты называются объектами-исключениями.
Жизненный цикл объектов-исключений начинается с возбуждения исключительной ситуации посредством оператора throw:

throw "Illegal cast";      // char *
throw IllegalCast();       // class IllegalCast

enum EPrgStatus {OK, BADINDEX, ILLEGALCAST};
throw ILLEGALCAST;         // enum EPrgStatus

ФУНКЦИОНАЛЬНЫЕ ЗАЩИЩЕННЫЕ БЛОКИ
Как защищенный блок может быть оформлена не только часть функции, но и функция целиком(в том числе main() и конструкторы классов). В таком случае защищенный блок называется функциональным.

void foobar()
try {
   // ...
}
catch(/* ... */) {/* ... */}
catch(/* ... */) {/* ... */}
catch(/* ... */) {/* ... */}

РАСКРУТКА СТЕКА И УНИЧТОЖЕНИЕ ОБЪЕКТОВ
Поиск catch-блока, пригодного для обработки возбужденного исключения, приводит к раскрутке стека - последовательному выходу из составных операторов и определений функций.
В ходе раскрутки стека происходит уничтожение локальных объектов, определенных в покидаемых областях видимости. При это деструкторы локальных объектов вызываются штатным образом(строгая гарантия С++).
Исключения, для обработки которого не найден catch-блок, инициируют запуск функции terminate(), передающий управление функции abort(), которая аварийно завершает программу.

ПОВТОРНОЕ ВОЗБУЖДЕНИЕ ИСКЛЮЧЕНИЯ И УНИВЕРСАЛЬНЫЙ БЛОК-ОБРАБОТЧИК
Оператор throw без параметров помещается(только) в catch-блок и повторно возбуждает обрабатываемое исключение. При этом его копия не создается:

throw;

Особая форма блока-обработчика исключений осуществялет перехват любых исключений:
catch(...) {/* ... */}

БЕЗОПАСНОСТЬ ПО КАК ПОКАЗАТЕЛЬ КАЧЕСТВА
Безопасноть - один из показателей качества ПО, оцениваемый путем статического анализа состава и взаимосвязей используемых компонентов, исходного кода и схемы БД.
Для обеспечения "структурной безопасности" исходного кода необходимо соблюдение стандартов разработки архитектуры и стандартов кодирования.
Примечание: См. модели качества ПО, описанные в стандартах:
   * ГОСТ ИСО/МЭК 9126-93. Информационная технология. Оценка программной продукции. Характеристики качества и руководства по их применению.
   * ISO/IEC 9126:2001. Softfare Engineering - Product Quality;
   * ISO/IEC 25010:2011. System and Software Engineering - Systems and software Quality Requirements and Evaluation(SQuaRE) - System and software quality models.
   
СТАНДАРТЫ КОДИРОВАНИЯ - ЗА "БЕЗОПАСНЫЙ КОД"
Структурная безопасность исходного кода ПО требует соблюдения определенных техник кодирования, одной из которых является систематическая обработка ошибок и исключительных ситуаций на всех уровнях программной архитектуры(уровень представления, уровень логики, уровень данных).
Одним из элементов обработки ошибок и исключений является спецификация(ограничение) типов исключений, которые могут порождать структурные элементы кода

БЕЗОПАСНОСТЬ КЛАССОВ И МЕТОДОВ
Функция С++ безопасна, если она не возбуждает никаких исключений или все возбужденные внутри нее исключения обрабатываются в ее теле.
Класс С++ безопасен, если безопасны все его методы.
В свою очередь, небезопасные функции могут специфицировать исключения, возбуждением которых(и только их!) способно завершиться исполнение таких функций. Обнаруженное при исполнении нарушение гарантии влечет за собой выхов функции unexpected(), по умолчанию вызывающей terminate().
Виртуальные функции в производных классах могут повторять спецификации исключений функций в базовых классов или накладывать более строгие ограничения.

БЕЗОПАСНОСТЬ КЛАССОВ И МЕТОДОВ: ПРИМЕР
// описание функций
int foo(int &i) throw();
bool bar (char *pc = 0) throw(IllegalCast);
void foobar() throw(IllegalCast, BadIndex);

// определение функций
int foo(int &i) throw() { /* ... */ }
bool bar (char *pc = 0) throw(IllegalCast) { /* ... */ }
void foobar() throw(IllegalCast, BadIndex) { /* ... */ }


БЕЗОПАСНОСТЬ КОНСТРУКТОРОВ
Конструкторы, как и другие методы классов, могут возбуждать исключения.
Для обработки всех исключений, возникших при исполнении конструктора, его тело и список инициализации должны быть совместно помещены в фунционально защищенных блок.

Beta::Beta(int value)
try: Alpha(foo(value)) {
   // ...
}
catch(...) {
   // ...
}

БЕЗОПАСНОСТЬ ДЕСТРУКТОРОВ
Деструкторы классов не должны возбуждать исключения. Одной из причин этого является необходимость корректного освобождения ресурсов, занятых массивами и коллекциями объектов:
   * если вызываемая в деструкторе функция может возбудить исключение, деструктор должен перехватить и обработка его (возможно, прервав программу)
   * если возможность реакции на исключение необходима клиентам класса во время некоторой операции, в его открытом интерфейсе должны быть функция(не деструктор!), которая текущую операцию выполняет.

В общем случае деструктор класса может специфицироваться как throw():
~Alpha() throw();

БЕЗОПАСНОСТЬ ИЛИ НЕЙТРАЛЬНОСТЬ КОДА?
От безопасности программного кода важно отличать нейтральность, под которой, согласно терминалогии Г.Саттера(Herb Satter), следует понимать способность методов класса прозрачно "пропускать сквозь себя" объекты исключения, полученные ими на обработку, но не предназначенные для них.
Нейтральный метод:
   * может обрабатывать исключения;
   * должен ретранслировать полученные им исключения методу-обработчику в неизменном виде и сохранять свою работоспособность при любых обстоятельствах.


ПОЛЬЗОВАТЕЛЬСКИЕ И СТАНДАРТНЫЕ КЛАССА ИСКЛЮЧИТЕЛЬНЫХ СИТУАЦИЙ
Для передачи из точки возбуждения исключения в точку его обработки сведений об условиях возникновения аномалии программист может определять и использовать собственные классы исключительных ситуаций
Такие класса могут быть сколько угодно простыми(включая пустые) или сложными(содержащие члены данных, конструкторы, деструкторы и интерфейсные методы)
Стандартная библиотека языка С++ содержит собственную иерархию классов исключений, являющихся прямыми или косвенными потомками базового класса exception. Потомки класса exception условно представляют две категории ошибок: логические ошибки и ошибки времени выполнения


КЛАСС std::exception
// namespace std
class exception {
   public:
      exception() throw();
      exception(const exception &) throw();
      exception& operator = (const exception &) throw();
      
      virtual ~exception() throw();
      virtual const char* what() const throw();
};

СТАНДАРТНЫЕ КЛАССЫ - ЛОГИЧЕСКИЕ ОШИБКИ
В число классов категории "логические ошибки" входят базовый промежуточный класс std::logic_error, а также производные от него специализированные классы:
   * std::invalid_argument - ошибка "неверный аргумент"
   * std::out_of_range     - ошибка "вне диапазона"
   * std::length_error     - ошибка "неверная длина"
   * std::domain_error     - ошибка "вне допустимой области"
   
СТАНДАРТНЫЕ КЛАССЫ - ОШИБКИ ВРЕМЕНИ ВЫПОЛНЕНИЯ
В число классов категории "ошибки времени выполнения" входят базовый промежуточный класс std::runtime_error, а также производные от него специаилизированные классы:
   std::range_error        - ошибка диапазона;
   std::overflow_error     - переполнение
   std::underflow_error    - потеря значимости

   
ПРОЧИЕ КЛАССЫ ИСКЛЮЧЕНИЙ СТАНДАРТНОЙ БИБЛИОТЕКИ
Также производными от std::exception являются классы std::bad_alloc и std::bad_cast, сигнализирующие об ошибках при выделении динамической памяти и неудаче при выполнении "ссылочного" варианта операции dynamic_cast, соответственно.















































