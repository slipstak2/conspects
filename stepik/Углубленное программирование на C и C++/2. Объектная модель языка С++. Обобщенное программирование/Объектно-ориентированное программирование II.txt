НАСЛЕДОВАНИЕ: КЛЮЧЕВЫЕ ПОНЯТИЯ
Наследование содействует повторному использование аттрибутов и методов класса, а значит, делает процесс разработки ПО более эффективным. Возникающие между классами А и В отношение наследования позволяют, например, говорить, что:
   * класс А является базовым(родительским) классом, классом-предком, надклассом(superclass)
   * класс В ялвяется производным(дочерним) классом, классом-потомком, подклассом(subclass)
Отношение наследования связывается классы в иерархию наследования, вид которой зависит от числа базовых классов у каждого производного:
   * при одиночном наследовании иерархия имеет вид дерева
   * при множественном наследовании - вид направленного ациклического графа(НАГ) произвольного вида

Переход от подкласса к надклассу - ОБОБЩЕНИЕ
Переход от надкласса к подклассу - СПЕЦИАЛИЗАЦИЯ

ПОЛИМОРФИЗМ ПОДКЛАССОВ
В том случае если базовый и производный классы имеют общий открытый интерфейс, говорорят, что производный класс представляет собой подкласс базового
Отношение между классом и подклассом, позволяющее указателю или ссылке на базовый класс без вмешательства программиста адресовать объект производного класса, возникает в С++ благодаря поддержке полиморфизма.
Полиморфизм позволяет предложить такую реализацию ядра объектно-ориентированного приложения, которая не будет зависеть от конктректных используемых подклассов.

РАНЕЕ И ПОЗДНЕЕ СВЯЗЫВАНИЕ
В рамках классического объектного подхода, - а равно и процедурного программирования, - адрес вызываемой функции(метода класса) определяется на этапе компиляции(сборки). Такой порядок связывания вызова функции и ее адреса получил название раннего(статического).
Позднее (динамическое) связывание состоит в нахождении (разрешении) нужной функции во время исполнения кода. При этом работа по разрешению типов перекладывается с программиста на компилятор.
В языке С++ динамическое связывание поддерживается механизмом виртуальных методов класса, для работы с которыми компиляторы строят таблицы виртуальных методов(VMT, virtual method table)

ОПРЕДЕЛЕНИЕ НАСЛЕДОВАНИЯ: ПРИМЕР
// описание производного класса (не включает список базовых классов)
class Deposit;

class Account {
   // ...
};

class Depost : public Account {
   // ...
}

ЗАЩИЩЕННЫЕ И ЗАКРЫТЫЕ ЧЛЕНЫ КЛАССА
Атрибуты и методы базового класса, как правило, должны быть непосредственно доступны для производных классов и непосредствено недоступны для прочих компонентов программы.
В этом случае они помещаются в секцию protected, в результате чего защищенные члены данных и методы базового класса:
   - доступны производному классу(прямому потомку)
   - недоступны классам вне рассматриваемой иерархии, глобальным функциям и вызывающей программе.
Если наличие прямого доступа к члену класса со стороны производных классов нежелательно, он вводится как закрытый.
Закрытые члены класса не наследуются потомками. Для доступа к ним класс-потомок должен быть объявлен в классе-предке как дружественный. Отношение дружественности не наследуется.

ПЕРЕГРУЗКА И ПЕРЕКРЫТИЕ ЧЛЕНОВ КЛАССА
Члены данных базового класса могут перекрываться одноименными членами данных производного класса, при этом их типы не должны обязательно совпадать(Для доступа к члену базового класса его имя должно быть квалифицировано)
Методы базового и производного классов не образуют множество перегруженных функций. В этом случае методы производного класса  не перегружают(overload), а перекрывают(ovveride) методы базового.
Для явного создания объединенного множества перегруженных функций базового и производного классов используется объявление using, которое вводит именованный член базового класса в область видимости производного.
Примечание: в область видимости производного класса попадают все одноименные методы базового класса ,а не только некоторые из них.

ПЕРЕГРУЗКА И ПЕРЕКРЫТИЕ ЧЛЕНОВ КЛАССА: ПРИМЕР
class Account {
   void display(const char * fmt);
   void display(const int mode = 0);
};

class Deposit : public Account {
   void display(sconst std::string &fmt);
   using Account::display; // чтобы не перекрывало методы из базового класса
   // ...
}

ПОРЯДОК ВЫЗОВА КОНСТРУКТОРОВ ПРОИЗВОДНЫХ КЛАССОВ:
Порядок вызова конструкторов объектов-членов, а также базовых классов при построении объекта производного класса не зависит от порядка их перечисления в списке инициализации конструктора производного класса и является следующим:
   - конструктор базового класса(если таковых несколько, конструкторы вызываются в порядке перечисления имен классов в списке базовых классов)
   - конструктор объекта-члена(если таковых несколько, конструкторы вызываются в порядке объявления членов данных в определении класса)
   - конструктор производного класса.
Конструктор производного класса может вызывать конструкторы классов, непосредственно являющихся базовыми для данного(прямых предков), и - без учета виртуального наследования - только их.
Примечание: правильно спроектированный конструктор производного класса не должен инициализировать атрибуты базового класса напрямую(путем присваивания значений)

class Alpha {
   public:
      Alpha();
      Alpha(int i); // ...
};

class Beta : public Alpha {
   public:
      Beta() : _s("dictum factum") {}
      // Beta() : Alpha(), _s("dictum factum") {}
      Beta(int i, std::string s) : Alpha(i), _s(s) {}
   protected:
      std::string _s;   // ...
}

ПОРЯДОК ВЫЗОВА ДЕСТРУКТОРОВ ПРОИЗВОДНЫХ КЛАССОВ
Порядок вызова деструкторов при уничтожении объекта производного класса прямо противоположен порядку вызова конструкторов и является следующим:
   - деструктор производного класса
   - деструктор объекта-члена(или нескольких)
   - деструктор базового класса(или нескольких)
Взаимная противположность порядка вызова конструкторов и деструкторов является строгой гарантией языка С++.


ВИРТУАЛЬНЫЕ ФУНКЦИИ
Методы, результат разрешения вызова которых зависит от "реального"(динамического) типа объекта, доступного по указателю или ссылке, называется виртуальным и при определении в базовом классе снабжается спецификатором virtual.
Примечание: в этом контексте тип непосредственно определяемого экземпляра, ссылки или указателя на объект называется статическим. Для самого объекта любого типа(автоматической переменной) статический и динамический тип совпадают.
По умолчанию объектная модель С++ работает с невиртуальными методами. Механизм виртуальных функций работает только в случае косвенной адресации(по указателю или ссылке)
Значения формальных параметров виртуальных функций определеются (а) на этапе компиляции (б) типом объекта, через который осуществялется вызов.
Отмена действия механизма виртуализации возможно и достигается статическим вызовом метода при помощи операции разрешения области видимости(::).
struct Alpha {
   // возможен вызов Alpha::display()
  virtual void display(); 
};
struct Beta : public Alpha {
   void display();   // Возможет вызов Beta::display();
}

ВИРТУАЛЬНЫЙ ОДНАЖДЫ - ВИРТУАЛЬНЫЙ НАВСЕГДА

ЯВНОЕ ПЕРЕКРЫТИЕ ВИРТУАЛЬНЫХ ФУНКЦИЙ: ПРИМЕР(С++11)
struct Alpha {
   virtual void foo();
   void bar();
};

struct Beta : public Alpha {
   // спецификатор override гарантирует, что функция(а) является виртуальной и (б) перекрывает виртуальную функцию 
   // базового класса с идентичной ей сигнатурой
   void foo() override;             // допустимо
   // void foo() const override;    // недопустимо
   // void bar() override;          // недопустимо
};

ЧИСТЫЕ ВИРТУАЛЬНЫЕ ФУНКЦИИ
Класс, в котором виртуальный метод описывается впервые, должен определять его тело либо декларировать метод как не имеющую собственной реализации чистую виртуальную функцию
Производный класс может наследовать реализацию виртуального метода из базового класса или перекрывать его собственной реализацией, при этом прототипы обеих реализаций обязаны совпадать
virtual void display() = 0;
Примечание: единственное исключение С++ делается для возвращаемого значения. Значение, возвращаемое реализацией в производном классе, может иметь тип, открыто наследующий классу значения, возвращаемого реализацией в базовом.


АБСТРАКТНЫЕ КЛАССЫ
Класс, который определяет или наследует хотя бы одну чистую виртуальные функцию, является абстрактным
Экземпляры абстрактных классов создавать нельзя. Абстракный класс может реализоваться как подъобъект производного, неабстрактного класса.
   - Аналогично этому нельзя использовать абстракные класс как типы параметров и возвращаемых значений методов(функций) или как тип результата операции явного приведения.
Чистые виртуальные функции могут иметь тело, определяемое строго вне тела класса. Обращение к телу чистой виртуальной функции может производиться только статически(при помощи операции разрешения области видимости), но не динамически(при помощи механизма виртуализации)

struct Alpha {
   virtual void display() = 0;
}

void Alpha::display() {/* ... */}

struct Beta : public Alpha {
   void display() {
      // статический(неполиморфный)
      // вызов чистой виртуальной функции
      Alpha::display();
   }
}

ДЕСТРУКТОР АБСТРАКТНЫХ КЛАССОВ
Деструктор класса может быть чистой виртуальной функцией, однако и в этом случае он должен(а не может, как в случае обычного метода класса) иметь тело(определяемое, очевидно, вне тела класса).
Причина, по которой деструктор может определяться как чиста виртуальная функция, обычно носит архитектураный характер: класс должен быть определен как абстрактный, а других функций-кандидатов на определение их чистыми виртуальными нет.

Полиморфное обращениек чистой виртуальной функции их деструктора(как, впрочем, и из конструктора) класса влечет за собой неопределенное поведение и в связи с этим запрещено.

struct Alpha {
   virtual ~Alpha() = 0;
}

Alpha:~Alpha() {}

struct Beta : public Alpha {};

// Alpha alpha    // недопустимо: абстрактный класс
Beta beta;        // допустимо

ФИНАЛЬНЫЕ МЕТОДИ ФИНАЛЬНЫЕ КЛАССЫ: ПРИМЕР(С++11)
struct Alpha {
   // спецификатор final гарантирует, что (1) функция 
   // (а) является виртуальной и (б) не может перекрываться
   // ЛИБО (2) класс не может быть базовым при наследовании
   virtual void foo() final;
   // void bar final;         // недопустимо
};

struct Beta final: public Alpha {
   //void foo();       // недопустимо
};

/*
struct Gamma : public Beta {}; // недопустимо
*/


МНОЖЕСТВЕННОЕ НАСЛЕДОВАНИЕ
Множественное наследование в ООП - это наследование от двух и более базовых классов, возможно, с различным уровнем доступа. Язык С++ не накладывает ограничений на количество базовых классов.
При множественном наследовании конструкторы базовых классов вызываются в порядке перечисления имен классов в списке базовых классов. Порядок вызоыва деструкторов ему прямо противоположен.
Унаследованные от разных базовых классов методы не образуют множество перегруженных функций, а потому разрешаются только по имени без учета их сигнатур.

ВИРТУАЛЬНОЕ НАСЛЕДОВАНИЕ
При множественном наследовании возможна ситуация неоднократного включения подобъекта одного и того же базового класса в состав производного. Связанные с нею проблемы и неоднозначности снимает виртуальное наследование.
Суть виртуального наследования - включение в состав класса единственного разделяемого подобъекта базового класса (виртуального базового класса)
Виртуальное наследование не характеризует базовый класс, а лишь описывает его отношение к производному.
Использование виртуального наследования должно быть взвешенным проектным решением конкретных проблем объектно-ориентированного проектирования.

ПОРЯДОК КОНСТРУИРОВАНИЯ ОБЪЕКТОВ ПРИ ВИРТУАЛЬНОМ НАСЛЕДОВАНИИ
Виртуальные базовые классы конструируются перед невиртуальными незавивисимо от их расположения в иерархии наследования.
Ответственность за инициализацию виртуального базового класса несет на себе ближайший(финальный) производный класс. В промежуточных производных классах прямые вызовы конструкторов виртуальных базовых классов автоматически подавляются.

// множественное наследование
class Alpha { /* ... */};

class Beta : public Alpha
{/* ... */};

class Gamma { /* ... */ };

class Delta: public Beta, public Gamma
{/* ... */};

// виртуальное наследование
class Alpha { /* ... */};
class Beta : virtual public Alpha
// то же: class Beta: public virtual Alpha
{/* ... */};

ЭЛИМИНАЦИЯ ПУСТЫХ БАЗОВЫХ КЛАССОВ
Размер любого объекта, а равно и подобъекта, должен составлять, как минимум, 1 байт, так как в противном случае невозможно гарантировать, что два наугад взятых(размещенных в адрессном пространстве) объекта одного типа никогда не будут размещены с одного адреса. Однако, это правило не распространяется на подобъекты базовых классов.
Элиминация пустой базы(empty base optimization) запрещена, если один из пустых базовых классов является одновременно типом(базовым классов для типа) первого нестатического члена данных, поскольку два базовых подобъекта одного типа должны иметь различные адреса.

struct Alpha {};
struct Beta : public Alpha {
   int n;
};
struct Gamma : public Alpha {
   Alpha a; // атрибут размера 1
   int n;
};
struct Delta: public Alpha {
   Beta b;     // атрибут размера sizeof(int)
   int n;
};

ПРИНЦИПЫ LSP, ISP И DIP (S.O.L.I.D)
Принцип подстановки Б.Лисков(Liskokov Substitution Principle, LSP) предполагает:
   Объекты любого класса могут заменяться объектами его подклассов, и это не должно влиять на свойства самой программы
Принцип разделения интерфейсов(Interface Segregation Principle, ISP) утверждает:
   Множество мелких интерфейсов лучше, чем единственный общий
Принцип инверсий зависимостей(Dependency Inversion Principle, DIP) гласит:
   Абстракции не должны зависеть от деталей реализации, обратно верно.
   
ДИНАМИЧЕСКАЯ ИДЕНТИФИКАЦИЯ ТИПОВ ВРЕМЕНИ ВЫПОЛНЕНИЯ (RTTI)
Динамическа идентификация типов времени выполнения(Real-Time Type Identifiaction) обеспечивает специальную поддержку полиморфизма и позволяет программе узнать реальный производны тип объекта, адресуемого по ссылке или по указателю на базовый класс. Поддержка RTTI в C++ реализована двумя операциями:
   - операция dynamic_cast поддерживает преобразование типов времени выполнения
   - операция typeid идентифицирует реальный тип выражения
Операции RTTI - это события времени выполнения для классов с виртуальными функциями и событиями времени компиляции для остальных типов. Исследование RTTI-информации полезно, в частности, при решении задач системного программирования.

ОПЕРАЦИЯ dynamic_cast
Встроенная унарная операция dynamic_cast языка С++ позволяет:
   - безопасно трансформировать указатель на базовый класс в указатель на производный класс(с возвратом нулевого указателя при невозможном выполнении трансформации)
   - преобразовывать леводопустимые значения, ссылающиеся на базовый класс, в ссылки на производный класс (с возбуждением исключения bad_cast при ошибке).
Единственным операндом dynamic_cast должен являться тип класса, в котором имеется хотя бы один виртуальный метод.

// классы Alpha и Beta образуют полиморфную иерархию, в которой класс Beta открыто наследует классу Alpha
Alpha * Alpha = new Beta;
if (Beta *beta = dynamic_cast<Beta*>(alpha)) {
   // успешно...
} else {
   // неуспешно ...
}

#include <typeinfo>  // для std::bad_cast

void foo(Alpha &alpha) {
   // ...
   try {
      Beta &beta = dynamic_cast<Beta&>(alpha);
   } catch(std::bad_cast) {/* ... */}
}

ОПЕРАЦИЯ typeid
Встроенная унарная операция typeid:
   - позволяет установить фактический тип выражения-операнда
   - может использоваться с выражениями и именами любых типов(включая выражения встроеннных типов и константы)
Если операнд typeid принадлежит типу класса с одной и более виртуальными функциями(не указателю на него!), результат typeid может не совпадать с типом самого выражения.
Операция typeid имеет тип (возвращает значение типа) type_info и требует подключения заголовочного файла <typeinfo>

Реализация класса type_info зависит от компилятора, но в общем и целом позволяет получить результат в виде неизменяемой С-строки(const char*), присваиваия объекты type_info друг другу(operator =), а также сравнивать их на равенство и неравенство(operator ==, operator !-).

#include <typeinfo>  // для type_info
Alpha *alpha = new Alpha;

if (typeid(alpha) == typeid(Alpha*)) /* ... */
if (typeid(*alpha) == typeid(Alpha)) /* ... */ 

ВОПРОСЫ ПРОИЗВОДИТЕЛЬНОСТИ 
   - Глубина цепочки наследования не увеличивает затраты времени и не ограничивает доступ к унаследованным членам базовых классов
   - Вызов виртуальной функции в большинстве случае не менее эффективен, чем косвенный вызов функции по указателю на нее.
   - При использовании встроенных конструкторов глубина иерархии наследования почти не влияет на производительность.
   - Отмена действия механизма виртуализации, как правило, необходима по соображениями повышения эффективности

























































