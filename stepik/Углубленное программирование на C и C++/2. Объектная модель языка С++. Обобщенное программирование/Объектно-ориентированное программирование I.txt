ИНКАПСУЛЯЦИЯ - БАЗОВЫЙ ПРИНЦИП ООП
Инкапсуляция, или сокрытие реализации, является фундаментом объектного подхода к разработке ПО
   * Следую данному подходу, программист рассматривает задачу в терминах предметной области, а создаваемый им продукт видит как совокупность абстрактных сущностей - классов(в свою очередь формально являющихся пользовательскими типами)
   * Инкапсуляция предотвращает прямой достук к внутреннему представлению класса из других классов и функций программы
   * Инкапсуляция предотвращает прямой доступ к внутреннему представлению класса из других классов и функций программы
   * Без нее теряют смысл остальные основополагающие принципы ООП: наследования и полиморфизм. Сущность инкапсуляции можно отразить формулой: ОТКРЫТЫЙ ИНТЕРФЕЙС + СКРЫТАЯ РЕАЛИЗАЦИЯ
   

КЛАСС: В УЗКОМ ИЛИ ШИРОКОМ СМЫСЛЕ?

Принцип инкапсуляции распространяется не только на классы(class), но и на структуры(struct), а также объединения(union). Это связано с расширительными толкованием понятия "класс" в языке С++, трактуемом как в узком, так и широком смысле:
   - класс в узком смысле - одноименный составной пользовательский тип данных, являющися контейнером для данных и алгоритмов их обработки. Вводится в текст программы определением типа со спецификатором class.
   - класс в широком смысле - любой составной пользовательский тип данных, агрегирующий данные и алгоритмы их обработки. Вводится в текст программы определением типа с одним из спецификаторов struct, union или class
   
Каждое определение класса вводит новый типа данных. Тело класса определяет полный перечеть его членов, который не может быть расширен после закрытия тела.

УКАЗАТЕЛЬ this

Указатель this - неявно определеяемый константный указатель на объект класса, через который происходит вызов соответствующего нестатического метода(чьем "нулевым" неявным параметром он является)
Для неконстантный устойчивых методов класса T имеет тип T *const, для констанных - имеет тип const T *const, для неустойчивых - volatile T *const.
Указатель this допускает разыменовывания(*this) и его применение внутри методов допустимо, но чаще всего излишне. Исключение составляют две ситуации:
   * сравнение адресов объектов:
      if (this != someObj) /*...*/
   * оператор return:
      return *this;
      
      
Класс как область видимости
Класс - наряду с блоком, функцией и пространством имен - является конструкцией С++, которая вводит в состав программы одноименную область видимости.(Строго говоря, область видимости вводит определение класса, а именного его тело)
   - Все члены класса видны в нем самом с момента своего объявления. Порядок объявления членов класса важен: нельзя ссылаться на члены которые предстоит объявить позднее. Исключение составляет разрешение имен в определенных встоенных методов, а также имен(статических членов), используемых как аргументы по умолчанию.
   
В области видимости класса находится не только его тело, но и внешние определения его членов: методов и статических аттрибутов

КОНСТРУКТОРЫ И ДЕСТРУКТОРЫ
Выполнение любого конструктора состоит из двух фаз:
   - фаза явной (неявной) инициализации(обработка списка инициализации)
   - фаза вычислений(исполнение тела конструктора)

Конструктор не может определяться со спецификатором const и volatile. Константность и неустойчивость объекта устанавливается по завершении работы конструктора и снимается перед вызовом деструктора

ИНИЦИАЛИЗАЦИЯ БЕЗ КОНСТРУКТОРА
Класс, все члены которого открыты, может задействовать механизм явной позиционной инициализации, ассоциирующий значение в списке инициализации с членами данных в соответствии с их порядком

struct Sample {
   int            int_prm;
   double         dbl_prm;
   std::string    str_prm;
};

Sample sample = { 1, -3.14, "dictum factum" };

Преимуществами такой техники выступают:
   - скорость и эффектиность, особо значимые при выполнении во время запуска программы(для глобальных объектов)
Недостатками инициализации без конструктора являются:
   - пригодность только для классов, члены которых открыты
   - отсутствие поддержки инкапсуляции и абстрактных типов
   - требования предельной точности и аккуратности в применении
   

КОНСТРУКТОР ПО УМОЛЧАНИЮ
   Явный конструктор по умолчанию не требует задания значений его параметров, хотя таковые могут присутствовать в сигнатуре(но в таком случае должны иметь значения по умолчанию)
   
struct Sample {
   Sample(int ipr = 0, double dpr = 0.0);
   // ...
}

Наличие формальныхй параметров в конструкторе по умолчанию позволяет сократить общее число конструкторов и объем исходного кода
Если в классе определен хотя бы один конструктор с параметрами, то при искользовании класса со стандартными контейнерами и динамическими массивами экземпляров конструктор по умолчанию обязателен.

Sample *samples = new Sample[NUM_OF_SAMPLES];

Если конструктор по умолчанию не определен, но существует хотя бы один конструктор с параметрами, в определении объектов должны присутствовать аргументы. Если ни одного конструктора не определено, объект класса не инициализируется(память под статическими объектами по общим правилам обнуляется)

struct Sample {
   Sample(int prm) : _prm(prm) {}
private:
   int _prm;
}

// все вызовы конструктора допустимы и эквивалентны
Sample sample1(10),
       sample2 = Sample(10),
       sample3 = 10; // для одного аргумента


// массивы объектов класса определеяются
// аналогично массивам объектов базовых типов

// для конструктора с одним аргументом
Sample array1[] = { 10, -5, 0, 127 };

// для конструктора с несколькими аргументами
Sample array2[5] = {
   Sample(10, 0.1),
   Sample(-5, -3.6),
   Sample(0, 0.0),
   Sample() // если есть конструктор по умолчанию
}

ЗАКРЫТЫЕ И ЗАЩИЩЕННЫЕ КОНСТРУКТОРЫ
Описание конструктора класса как защищенного или закрытого дает возможность ограничить или полностью запретить отдельные способы создания объектов класса
В большинстве случае закрытые и защищенные конструкторы используются для:
   - предотвращения копирования одного объекта в другой
   - указание того, что конструктор должен вызываться только для создания подобъектов базового класса в объекте призвольного класса, а не создание объектов, непосредственно доступных в коде программы.

ПОЧЛЕННАЯ ИНИЦИАЛИЗАЦИЯ И ПРИСВАИВАНИЕ
Почленная инициализация по умолчанию - механизм инициализации одного объекта класса другим объектом того же класса, который активизируется независимо от наличия в определении класса явного конструктора
Почленная инициализация по умолчанию происходит в следующих ситуациях:
   - явная инициализация одного объекта другим.
   - передача объекта класса в качестве аргумента функции
   - передача объекта класса в качестве возвращаемого функцией значения
   - определение непустого стандартного последовательного контейнера
   - вставка объекта класса в стандартный контейнер
Почленная инициализация по умолчанию подавляется при наличии в определении класса конструктора копивароиян
Запрет почленной инициализации по умолчанию осуществялется одним из следующих способов:
   - описание закрытого конструктора копирования(не действует для методов класса и дружественных объектов)
   - описание конструктора копирования без его определения(действует всюду)

Почленное присваивание по умолчанию - механизм присваивания одному объекту класса значение другого объекта того же класса, отличный от почленной иницилаизации по умолчанию использованием копирующей операции-функции присваивания вместо конструктора присваивания

КОНСТРУКТОРЫ КОПИРОВАНИЯ
Конструктор копирования принимает в качестве первого формального параметра ссылку на существующий объект класса. Другими словами, этот параметр имеет типа T&, const T&, volatile T& или const volatile T&.
Второй и последующие параметры конструктора копирования, если есть, должны иметь значения по умолчанию.
В случае отсутствия явного конструктора копирования в определении класса производится почленная инициализация объекта по умолчанию.

struct Sample {
   Sample(const Sample &rhs);
   // ...
}

КОНСТРУКТОРЫ И ОПЕРАЦИИ ПРЕОБРАЗОВАНИЯ
Конструкторы преобразования служат для построения объектов класса по одному или нескольким значения иных типов.
Операции преобразования позволяют преобразовывать содержимое объектов класса к требуемым типа данных
struct Sample {
   // конструкторы преобразования
   Sample(const char *);
   Sample(const std::string &);
   
   // Операции преобразования
   operator int   () { return int_prm; }
   operator double() { return dlb_prm; }
};

СПИСОК ИНИАЛИЗАЦИИ НЕСТАТИЧЕСКИХ ЧЛЕНОВ ДАННЫХ
Выполнение любого конструктора состоит из двух фаз:
   * фаза явной(неявной) инициализации(обработка списка инициализации) - предполагает иницилаизацию членов данных
   * фаза вычислений(исполнение тела конструктора) - предаполагает присваивание значений(в предварительно инициализованных областях памяти).

Присваиваине значение членам данных - объектам классов в теле конструктора неэффективно ввиду ранее произведенной инициализации по умолчанию. Присвание значений членам данных, представляющих "старые" базовые типы, по эффективности равнозначно инициализации.
К началу исполнения тела конструктора все константные члены члены-ссылки должны быть инициалированы.


ДЕСТРУКТОРЫ. ВЕРТУАЛЬНЫЕ ДЕСТРУКТОРЫ
Деструктор - не принимающий параметров и не возвращающий результат метод класа, автоматически вызываемый при выходе объекта из области видимости и применении к указателю на объект класса операции delete

struct Sample {
   // ...
   virtual ~Sample();
}

Примечание: деструктор не вызывается при выходе из области видимости ссылки или указателя на объект

Типовые задачи деструктора: 
   - сброс содержимого программных буферов в долговременные хранилища
   - освобождение(возврат) системных ресурсов, главным образом - оперативной памяти.
   - закрытие файлов или устройств.
   - снятие блокировок, останов таймеров и т.д.
Для обеспечения корректного освобождения ресурсов объектами производных классов деструкторы в полиморфных иерархиях, как правило, определяют как виртуальные

ЯВНЫЙ ВЫЗОВ ДЕСТРУКТОРА
Потребность в явном вызове деструктора обычно связана с необходимостью уничтожить динамически размещенный объект без освобождения памяти

char *buf = new char [sizeof(Sample)]
// "размещающий" вариант new
Sample *psmp1 = new (buf) Sample(100);
psmp1->~Sample()     // Вызов 1

Sample *psmp2 = new (buf) Sample(200);
//...
psmp2->~Sample()  // вызов 2
delete [] buf;

СКОБОЧНЫЕ ИНИЦИАЛИЗАТОРЫ ЧЛЕНОВ ДАННЫХ(С++ 11)
#include <iostream>
int counter = int();

struct Sample {
   // скобочные и приравнивающие инициализаторы
   // (brace-or-equal initializers) 
   std::string msg{"Abeunt studio is mores"};   // форма 1
   int id = ++counter;                          // форма 2
   int n{42};                                   // форма 3
   
   // приравнивающий инициализатор
   // с вычисляемым операндом (n)
   static const std::size_t sz = sizeof n;
   
   Sample() {}             // msg == "Abeunt studio is mores", n == 42
   Sample(int _n) : n(_n)  // msg == "Abeunt studio is mores", n == _n
}

СЕМАНТИКА ПЕРЕНОСА (С++11)
Введение в С++11 семантики переноса(англ. move semantics) обогащает язык возможностями более тонкого и эффектиновго управления памятью данных, устраняющего копирование объектов там, где оно нецелесообразно. Технически семантика переноса реализацется при помощи ссылок на праводопустимые выражения(англ. expiring value, xvalue) и конструкторов переноса.
Конструкторы переноса не создают точную копию своего параметра, а "отнимают" его ресурсы(указатели на участки программной кучи, дескрипторы файлов, потоки ввода-вывода, потоки исполнения, TCP-сокеты и т.д.), передавая права владения ими вновь создаваемому объекту. Параметр конструктора переноса остается в корректном, но неопределенном состоянии. Отсутствие поддержки классом семантики переноса - не ошибка, но упущенная возможность оптимизации

class Alpha {
   public:
      Alpha();
      Alpha(const Alpha &a);  // конструктор копирования
      Alpha(Alpha &&a);       // конструктор переноса
      ~Alpha();
   private:
      std::size_t sz;
      double *d;
}

Alpha:Alpha() : sz(0), d(NULL) {}
Alpha:~Alpha() { delete [] d; }

// конструктор копирования
Alpha::Alpha(const Alpha &a) : sz(a.sz) {
   d = new double[sz];
   //...
   for (std::size_t i = 0; i < sz; i++)
      d[i] = a.d[i];
}

// конструктор переноса
Alpha::Alpha(Alpha &&a) : sz(a.sz) {
   d    = a.d;
   a.d  = nullptr; // перенастройка параметра, С++11
   a.sz = 0;
}

Alpha foo (Alpha arg) { return arg; }
void bar(Alpha arg) {}
int main(void) {
   // вызов Alpha::Alpha(Alpha&&) при возврате из функции с сигнатурой  Alpha f(/* ... */)
   Alpha alp1 = foo(Alpha());
   // вызов Alpha::Alpha(Alpha&&) при инициализации
   Alpha alp2 = std::move(alp1)  // alp2(std::move(alp1))
   // вызов Alpha::Alpha(Alpha&&) при передаче параметра функции void g(Alpha)
   bar(std::move(alp2));
}

ОПЕРАЦИЯ-ФУНКЦИЯ ПРИСВАИВАНИЯ С ПЕРЕНОСОМ
#include <iostream>
struct Beta {
   // явно определенная операция-функция присваивания
   // делает конструкторы T::T(), T::T(T&) удаленными
   Beta() = default;
   Beta(const Beta&) = default; 
   Beta& operator=(Beta &&rhs) {
      msg = std::move(rhs.msg);
      return *this;
   }
   std::string msg;
}

int main () {
   Beta beta = {"Per aspera ad astra"}, gamma;
   gamma = std::move(beta);
   
   std::cout << gamma.msg << std::endl       // "Per aspera ad astra"
             << beta.msg  << std::endl;      // ""
}


РЕАЛИЗАЦИЯ ПРИСВАИВАНИЯ ЧЕРЕЗ ВЫЗОВ КОНСТРУКТОРА(С++11)
class T {
   public:  // функции ::acquire/::release являются вымышленными
      explicit T(const std::string& _name):
         handle(::acquire(_name)) {}
      T(T&& rhs) : handle{rhs.handle} { rhs.handle = nullptr; }
      T& operator = (T&& rhs) {  // ресурсом владеет rhs
         T copy{std::move(rhs)}; // ресурсом владеет copy
         std::swap(handle, copy.handle); // владеет *this
         return *this;  // для copy вызывается T::~T()
      }
      ~T() { ::release(handle); }
   private:
      resource_t handle;
}

АВТОМАТИЧЕСКИЙ ГЕНЕРИРУЕМЫЙ КОНСТРУКТОР ПО УМОЛЧАНИЮ
В случае отсуствия в классе явных конструкторов любого типа компилятор самостоятельно неявно определеяет конструктор по умолчанию как встаиваемый(inline) открытый(public) метод данного класса.
В ходе трансляции неявно определенный конструктор, - если он не удален и не является тривитальным, - по умолчанию генерируется(формируется на уровне тела функции) компилятором и работает точно так же, как явно определенный конструктор с пустым телом и пустым списком инициализации.
Примечание: в случае участия класса в иерархии наследования автоматически генерируемый конструктор по умолчанию вызывает конструкторы по умолчанию базовых классов и своих членов, не являющихся статическими.

ТРИВИАЛЬНЫЙ КОНСТРУКТОР ПО УМОЛЧАНИЮ
Конструктор по умолчанию является тривиальным, если одновременно соблюдаются все следующие условия:
   - конструктор определен неявно или определен как default;
   - клас не имеет виртуальных методов;
   - класс не имеет виртуальных базовых классов;
   - каждый непосредственный предо класса имеет тривиальный конструктор по умолчанию
   - каждый нестатический член класса имеет тривиальный конструктор по умолчанию
   
Тривиальный конструктор по умолчанию не совершает никаких действий. Объекты классов с таким конструктором - при условии соблюдения требований к выравниванию - могут создаваться при помощи reinterpret_cast в любом подходящем месте, к примеру, на участках программной кучи, запрошенных вызовом std::malloc();


АВТОМАТИЧЕСКИ ГЕНЕРИРУЕМЫЕ СПЕЦИАЛЬНЫЕ МЕТОДЫ ИНЫХ ВИДОВ
Сказанное выше справедливо также для конструкторов копирования, конструкторов переноса и деструктора класса:
   - в отсутсвии явно определенного конструктора копирвоания конструктор формируется компилятором автоматически как встраиваемый открытый метод с сигнатурой: T::T(const T&) или T::T(T&);
   - в отсутствии явно определенных конструктора переноса, конструкторов копирования, операций присваивания путем копирования, операций присваивания путем переноса, а также деструкторов конструктор переноса формируется компилятором автоматически как встраиваемый открытый метод с сигнатурой T::T(T &&)
   - в отсуствии явно определенного деструктора деструктор формируется компилятором автоматически как встраиваемый открытый метод с сигнатурой T::~T()
   
   
ПРИНУЖДЕНИЕ И ПОДАВЛЕНИЕ ГЕНЕРАЦИИ КОНСТРУКТОРОВ И ДЕСТРУКТОРОВ(С++11)
Автоматическая генерация конструктора по умолчанию, конструктора копирования, конструктора переноса или деструктора компилятором может быть как подавлена программистом, так и, наоборот, форсирована.

Class Sample {
   public:
   // запрет автогенерации конструктора по умолчанию
   Sample() = delete;
   Sample(int ipr, double dpr);
   // принудительная автогенерация деструктора по умолчанию
   ~Sample() = default;
}


ПОДАВЛЕНИЕ КОПИРОВАНИЯ
Для обеспечения эффективности объектного кода компилятору разрешено пропускать необязательные("лишние") вызовы конструкторов копирования и переноса, реализуя так называемую семантику передачи по значению без копирования(англ. zero-copy pass-by-value semantics).
   - Такому поведению компиляторов, известному как подавление копирования(англ. copy elision), не припятствует даже реализация конструкторами наблюдаемых внешне побочных действий. Примером ситуаций такого рода является оптимизация компиляции, известная как RVO и NRVO.
Подавление копирования - единственная разрешенная стандартом форма оптимизации, легально нарушающая правило "as-if" и способная повлиять на побочные действия вызова функций.
Программы, полагающиеся на побочные действия конструкторов и деструкторов классов, не являются переносимыми

ОПТИМИЗАЦИЯ RVO И NRVO
Оптимизация NRVO(англ. Named Return Value Optimization) - ситуация, в которой функция возвращаем объект класса по значение, а выражение в операторе return есть идентификатор устойчивого объекта с автоматическое продолжительностью хранения, не являющегося параметром самой функции и имеющего тот же тип без квалификатора const/volatile, что и тип результата функции.

Оптимизация RVO(англ. Return Value Optimization) - ситуация в которой анонимный временный объект является аргументов return.
   - Расширением RVO является оптимизация, при которой анонимный временный объект, не связанный с какой-либо ссылкой, копируется или переносится в объект того же типа без квалификаторов const/volatile.
Примечание: подавление в GCC может быть отключено флагом компиляции -fno-elide-constructors

ПРАВИЛО ТРЕХ
"Правило трех"(англ. Rule of Three) - если класс требует написание явно определеного деструктора, такого же конструктора копирования или операции присваивания, он почти наверное требует написания всех трех названных методов.
   - Неявно определенные специальные методы класса, как правило, неверно решают возложенную задачу, если класс управляет ресурсом, который доступен по описателю, не являющемуся классам(указатель T*, POSIX-дескриптор файла и пр.) деструктор не выполняет никаких действий, а конструктор копирования/операция присваивания осуществляет "поверхностное копирование" (описателя, а не управляемого/адресуемого ресурса)
Следствие. Для конструктора копирования и операции присваивания справедливо: определение одного метода как закрытого(private), удаленного(delete) или не имеющего реализации при наличии неявно определенной реализации другого чаще всего является признаком(влечет за собой) ошибки


ПРАВИЛО ПЯТИ [УМОЛЧАНИЙ]
"Правило пяти [умолчаний]"(англ. Rule of File [Defaults]) - так как наличие явно определенного деструктора, конструктора копирования или копирующей операции присваивания подавляет неявное определение конструктора переноса и операции присваивания с переносом, класс, требующий поддержки семантики переноса, должен включать определения всех пяти специальных методов(возможно, в виде = default).
Класс T, подчиняющийся "правилу пяти", гарантировано содержит:
   - явный конструктор копирования: напр. T::T(const T&)
   - явный конструктор переноса, напр. T::T(T&&)
   - явную операцию-функцию присваивания путем копирования, напр. T& operator = (const T&)
   - явную операцию-функцию присваивания путем переноса, напр. T& operator = (const T&&)
   - явный деструктор T::~T()

ПРАВИЛО НУЛЯ
"Правило нуля"(англ. Rule of Zero) - единственной зоной ответственности класса (ср.:принцип SRP-принцип единственной ответственности) с нестандартным деструктором, конструктором копирования/переноса или операцией-функцией присваивания путем копирования/переноса должно быть обслуживание ресурса, которым владее его соответствующий экземпляр(ср.: идиома RAII)

struct ruleOfZero {
   ruleOfZero(const std::string &_msg) : msg(_msg) {}
   private:
      std::string msg;
}

ИДИОМА RAII
Закрепление за конструкторами функции захвата, выделения, блокировки или инициаилизации ресурсов, а за деструкторами их возврата, освобождение и снятие установленных блокировок:
   - повзволяет безопасно обрабатывать ошибки и исключения
   - составляет суть одной из важнейшийх идиом ОО-программироваия RAII(англ. Resource Acquisition Is Initialization - "получение ресурса есть инициализация")
Работа идиомы RAII в языке С++ основана, главным образом, на гарантированном вызове деструкторов автоматических переменных, являющихся экземплярами классов, при выходе из соответствующих областей видимости.
Правильный выбор объекта владельца соотвествующего ресурса - лучшее средство в борьбе с утечкой ресурсов.

ПРИНЦИПЫ S.O.L.I.D.: НАЧАЛО
Принципы S.O.L.I.D. - устоявшееся обозначение "первой пятерки" принципов ООП и дизайна, сформулированных главным редактором С++ Report P. Мартином(Robert Martin) в начале 2000-x гг.
В число принципов S.O.L.I.D., обобщающих классические результаты 1980-1990-x гг., входят:
   * Принцип единственной ответственности [Р. Мартин]
   * Принцип открытости/закрытости [Б. Мейер (Bertrand Meyer)]
   * Принцип подстановки Лисков [Б. Лисков(Barbara Liskov) - Ж.Уинг (Jeannette Wing)]
   * Принцип разделения интерфейсов[Р. Мартин]
   * Принцип инверсии зависимостей [Р. Мартин]

ПРИНЦИП SRP и OCP(S.O.L.I.D.)
Принцип единственной ответственности (англ. Single Responsibility Principle, SRP) требует:
      Любой класс должен иметь одну и только одну зону ответственности

Принцип открытости/закрытости(Open/Closed Principle, OCP) гласит:
      Программные элементы должны быть открыты для расширения, но закрыты для изменения