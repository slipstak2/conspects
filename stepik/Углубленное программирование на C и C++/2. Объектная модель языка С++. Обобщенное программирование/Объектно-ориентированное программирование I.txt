ИНКАПСУЛЯЦИЯ - БАЗОВЫЙ ПРИНЦИП ООП
Инкапсуляция, или сокрытие реализации, является фундаментом объектного подхода к разработке ПО
   * Следую данному подходу, программист рассматривает задачу в терминах предметной области, а создаваемый им продукт видит как совокупность абстрактных сущностей - классов(в свою очередь формально являющихся пользовательскими типами)
   * Инкапсуляция предотвращает прямой достук к внутреннему представлению класса из других классов и функций программы
   * Инкапсуляция предотвращает прямой доступ к внутреннему представлению класса из других классов и функций программы
   * Без нее теряют смысл остальные основополагающие принципы ООП: наследования и полиморфизм. Сущность инкапсуляции можно отразить формулой: ОТКРЫТЫЙ ИНТЕРФЕЙС + СКРЫТАЯ РЕАЛИЗАЦИЯ
   

КЛАСС: В УЗКОМ ИЛИ ШИРОКОМ СМЫСЛЕ?

Принцип инкапсуляции распространяется не только на классы(class), но и на структуры(struct), а также объединения(union). Это связано с расширительными толкованием понятия "класс" в языке С++, трактуемом как в узком, так и широком смысле:
   - класс в узком смысле - одноименный составной пользовательский тип данных, являющися контейнером для данных и алгоритмов их обработки. Вводится в текст программы определением типа со спецификатором class.
   - класс в широком смысле - любой составной пользовательский тип данных, агрегирующий данные и алгоритмы их обработки. Вводится в текст программы определением типа с одним из спецификаторов struct, union или class
   
Каждое определение класса вводит новый типа данных. Тело класса определяет полный перечеть его членов, который не может быть расширен после закрытия тела.

УКАЗАТЕЛЬ this

Указатель this - неявно определеяемый константный указатель на объект класса, через который происходит вызов соответствующего нестатического метода(чьем "нулевым" неявным параметром он является)
Для неконстантный устойчивых методов класса T имеет тип T *const, для констанных - имеет тип const T *const, для неустойчивых - volatile T *const.
Указатель this допускает разыменовывания(*this) и его применение внутри методов допустимо, но чаще всего излишне. Исключение составляют две ситуации:
   * сравнение адресов объектов:
      if (this != someObj) /*...*/
   * оператор return:
      return *this;
      
      
Класс как область видимости
Класс - наряду с блоком, функцией и пространством имен - является конструкцией С++, которая вводит в состав программы одноименную область видимости.(Строго говоря, область видимости вводит определение класса, а именного его тело)
   - Все члены класса видны в нем самом с момента своего объявления. Порядок объявления членов класса важен: нельзя ссылаться на члены которые предстоит объявить позднее. Исключение составляет разрешение имен в определенных встоенных методов, а также имен(статических членов), используемых как аргументы по умолчанию.
   
В области видимости класса находится не только его тело, но и внешние определения его членов: методов и статических аттрибутов

КОНСТРУКТОРЫ И ДЕСТРУКТОРЫ
Выполнение любого конструктора состоит из двух фаз:
   - фаза явной (неявной) инициализации(обработка списка инициализации)
   - фаза вычислений(исполнение тела конструктора)

Конструктор не может определяться со спецификатором const и volatile. Константность и неустойчивость объекта устанавливается по завершении работы конструктора и снимается перед вызовом деструктора

ИНИЦИАЛИЗАЦИЯ БЕЗ КОНСТРУКТОРА
Класс, все члены которого открыты, может задействовать механизм явной позиционной инициализации, ассоциирующий значение в списке инициализации с членами данных в соответствии с их порядком

struct Sample {
   int            int_prm;
   double         dbl_prm;
   std::string    str_prm;
};

Sample sample = { 1, -3.14, "dictum factum" };

Преимуществами такой техники выступают:
   - скорость и эффектиность, особо значимые при выполнении во время запуска программы(для глобальных объектов)
Недостатками инициализации без конструктора являются:
   - пригодность только для классов, члены которых открыты
   - отсутствие поддержки инкапсуляции и абстрактных типов
   - требования предельной точности и аккуратности в применении
   

КОНСТРУКТОР ПО УМОЛЧАНИЮ
   Явный конструктор по умолчанию не требует задания значений его параметров, хотя таковые могут присутствовать в сигнатуре(но в таком случае должны иметь значения по умолчанию)
   
struct Sample {
   Sample(int ipr = 0, double dpr = 0.0);
   // ...
}

Наличие формальныхй параметров в конструкторе по умолчанию позволяет сократить общее число конструкторов и объем исходного кода
Если в классе определен хотя бы один конструктор с параметрами, то при искользовании класса со стандартными контейнерами и динамическими массивами экземпляров конструктор по умолчанию обязателен.

Sample *samples = new Sample[NUM_OF_SAMPLES];

Если конструктор по умолчанию не определен, но существует хотя бы один конструктор с параметрами, в определении объектов должны присутствовать аргументы. Если ни одного конструктора не определено, объект класса не инициализируется(память под статическими объектами по общим правилам обнуляется)

struct Sample {
   Sample(int prm) : _prm(prm) {}
private:
   int _prm;
}

// все вызовы конструктора допустимы и эквивалентны
Sample sample1(10),
       sample2 = Sample(10),
       sample3 = 10; // для одного аргумента


// массивы объектов класса определеяются
// аналогично массивам объектов базовых типов

// для конструктора с одним аргументом
Sample array1[] = { 10, -5, 0, 127 };

// для конструктора с несколькими аргументами
Sample array2[5] = {
   Sample(10, 0.1),
   Sample(-5, -3.6),
   Sample(0, 0.0),
   Sample() // если есть конструктор по умолчанию
}

ЗАКРЫТЫЕ И ЗАЩИЩЕННЫЕ КОНСТРУКТОРЫ
Описание конструктора класса как защищенного или закрытого дает возможность ограничить или полностью запретить отдельные способы создания объектов класса
В большинстве случае закрытые и защищенные конструкторы используются для:
   - предотвращения копирования одного объекта в другой
   - указание того, что конструктор должен вызываться только для создания подобъектов базового класса в объекте призвольного класса, а не создание объектов, непосредственно доступных в коде программы.

ПОЧЛЕННАЯ ИНИЦИАЛИЗАЦИЯ И ПРИСВАИВАНИЕ
Почленная инициализация по умолчанию - механизм инициализации одного объекта класса другим объектом того же класса, который активизируется независимо от наличия в определении класса явного конструктора
Почленная инициализация по умолчанию происходит в следующих ситуациях:
   - явная инициализация одного объекта другим.
   - передача объекта класса в качестве аргумента функции
   - передача объекта класса в качестве возвращаемого функцией значения
   - определение непустого стандартного последовательного контейнера
   - вставка объекта класса в стандартный контейнер
Почленная инициализация по умолчанию подавляется при наличии в определении класса конструктора копивароиян
Запрет почленной инициализации по умолчанию осуществялется одним из следующих способов:
   - описание закрытого конструктора копирования(не действует для методов класса и дружественных объектов)
   - описание конструктора копирования без его определения(действует всюду)

Почленное присваивание по умолчанию - механизм присваивания одному объекту класса значение другого объекта того же класса, отличный от почленной иницилаизации по умолчанию использованием копирующей операции-функции присваивания вместо конструктора присваивания

КОНСТРУКТОРЫ КОПИРОВАНИЯ
Конструктор копирования принимает в качестве первого формального параметра ссылку на существующий объект класса. Другими словами, этот параметр имеет типа T&, const T&, volatile T& или const volatile T&.
Второй и последующие параметры конструктора копирования, если есть, должны иметь значения по умолчанию.
В случае отсутствия явного конструктора копирования в определении класса производится почленная инициализация объекта по умолчанию.

struct Sample {
   Sample(const Sample &rhs);
   // ...
}

КОНСТРУКТОРЫ И ОПЕРАЦИИ ПРЕОБРАЗОВАНИЯ
Конструкторы преобразования служат для построения объектов класса по одному или нескольким значения иных типов.
Операции преобразования позволяют преобразовывать содержимое объектов класса к требуемым типа данных
struct Sample {
   // конструкторы преобразования
   Sample(const char *);
   Sample(const std::string &);
   
   // Операции преобразования
   operator int   () { return int_prm; }
   operator double() { return dlb_prm; }
};

СПИСОК ИНИАЛИЗАЦИИ НЕСТАТИЧЕСКИХ ЧЛЕНОВ ДАННЫХ
Выполнение любого конструктора состоит из двух фаз:
   * фаза явной(неявной) инициализации(обработка списка инициализации) - предполагает иницилаизацию членов данных
   * фаза вычислений(исполнение тела конструктора) - предаполагает присваивание значений(в предварительно инициализованных областях памяти).

Присваиваине значение членам данных - объектам классов в теле конструктора неэффективно ввиду ранее произведенной инициализации по умолчанию. Присвание значений членам данных, представляющих "старые" базовые типы, по эффективности равнозначно инициализации.
К началу исполнения тела конструктора все константные члены члены-ссылки должны быть инициалированы.



























